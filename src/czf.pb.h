// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: czf.proto

#ifndef PROTOBUF_czf_2eproto__INCLUDED
#define PROTOBUF_czf_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_czf_2eproto();
void protobuf_AssignDesc_czf_2eproto();
void protobuf_ShutdownFile_czf_2eproto();

class GameOrigin;
class Heartbeat;
class JobRequest;
class MCTSRoot;
class Model;
class Packet;
class PreprocessRequest;
class SearchRequest;
class SearchResponse;
class Trajectory;

enum JobType {
  UNKNOWN = 0,
  PREPROCESS = 1,
  SEARCH = 2,
  JobType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  JobType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool JobType_IsValid(int value);
const JobType JobType_MIN = UNKNOWN;
const JobType JobType_MAX = SEARCH;
const int JobType_ARRAYSIZE = JobType_MAX + 1;

const ::google::protobuf::EnumDescriptor* JobType_descriptor();
inline const ::std::string& JobType_Name(JobType value) {
  return ::google::protobuf::internal::NameOfEnum(
    JobType_descriptor(), value);
}
inline bool JobType_Parse(
    const ::std::string& name, JobType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JobType>(
    JobType_descriptor(), name, value);
}
// ===================================================================

class MCTSRoot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MCTSRoot) */ {
 public:
  MCTSRoot();
  virtual ~MCTSRoot();

  MCTSRoot(const MCTSRoot& from);

  inline MCTSRoot& operator=(const MCTSRoot& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MCTSRoot& default_instance();

  void Swap(MCTSRoot* other);

  // implements Message ----------------------------------------------

  inline MCTSRoot* New() const { return New(NULL); }

  MCTSRoot* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MCTSRoot& from);
  void MergeFrom(const MCTSRoot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MCTSRoot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value() const;
  void set_value(float value);

  // repeated float policy = 2;
  int policy_size() const;
  void clear_policy();
  static const int kPolicyFieldNumber = 2;
  float policy(int index) const;
  void set_policy(int index, float value);
  void add_policy(float value);
  const ::google::protobuf::RepeatedField< float >&
      policy() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_policy();

  // @@protoc_insertion_point(class_scope:MCTSRoot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< float > policy_;
  mutable int _policy_cached_byte_size_;
  float value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_czf_2eproto();
  friend void protobuf_AssignDesc_czf_2eproto();
  friend void protobuf_ShutdownFile_czf_2eproto();

  void InitAsDefaultInstance();
  static MCTSRoot* default_instance_;
};
// -------------------------------------------------------------------

class GameOrigin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameOrigin) */ {
 public:
  GameOrigin();
  virtual ~GameOrigin();

  GameOrigin(const GameOrigin& from);

  inline GameOrigin& operator=(const GameOrigin& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameOrigin& default_instance();

  void Swap(GameOrigin* other);

  // implements Message ----------------------------------------------

  inline GameOrigin* New() const { return New(NULL); }

  GameOrigin* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameOrigin& from);
  void MergeFrom(const GameOrigin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameOrigin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes node = 1;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::std::string& node() const;
  void set_node(const ::std::string& value);
  void set_node(const char* value);
  void set_node(const void* value, size_t size);
  ::std::string* mutable_node();
  ::std::string* release_node();
  void set_allocated_node(::std::string* node);

  // optional int32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameOrigin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr node_;
  ::google::protobuf::int32 index_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_czf_2eproto();
  friend void protobuf_AssignDesc_czf_2eproto();
  friend void protobuf_ShutdownFile_czf_2eproto();

  void InitAsDefaultInstance();
  static GameOrigin* default_instance_;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  void Swap(Model* other);

  // implements Message ----------------------------------------------

  inline Model* New() const { return New(NULL); }

  Model* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes blobs = 2;
  int blobs_size() const;
  void clear_blobs();
  static const int kBlobsFieldNumber = 2;
  const ::std::string& blobs(int index) const;
  ::std::string* mutable_blobs(int index);
  void set_blobs(int index, const ::std::string& value);
  void set_blobs(int index, const char* value);
  void set_blobs(int index, const void* value, size_t size);
  ::std::string* add_blobs();
  void add_blobs(const ::std::string& value);
  void add_blobs(const char* value);
  void add_blobs(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& blobs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_blobs();

  // @@protoc_insertion_point(class_scope:Model)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> blobs_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_czf_2eproto();
  friend void protobuf_AssignDesc_czf_2eproto();
  friend void protobuf_ShutdownFile_czf_2eproto();

  void InitAsDefaultInstance();
  static Model* default_instance_;
};
// -------------------------------------------------------------------

class Heartbeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Heartbeat) */ {
 public:
  Heartbeat();
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Heartbeat& default_instance();

  void Swap(Heartbeat* other);

  // implements Message ----------------------------------------------

  inline Heartbeat* New() const { return New(NULL); }

  Heartbeat* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Heartbeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Heartbeat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_czf_2eproto();
  friend void protobuf_AssignDesc_czf_2eproto();
  friend void protobuf_ShutdownFile_czf_2eproto();

  void InitAsDefaultInstance();
  static Heartbeat* default_instance_;
};
// -------------------------------------------------------------------

class JobRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:JobRequest) */ {
 public:
  JobRequest();
  virtual ~JobRequest();

  JobRequest(const JobRequest& from);

  inline JobRequest& operator=(const JobRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobRequest& default_instance();

  void Swap(JobRequest* other);

  // implements Message ----------------------------------------------

  inline JobRequest* New() const { return New(NULL); }

  JobRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobRequest& from);
  void MergeFrom(const JobRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JobRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .JobType job_type = 1;
  void clear_job_type();
  static const int kJobTypeFieldNumber = 1;
  ::JobType job_type() const;
  void set_job_type(::JobType value);

  // optional int32 vacancy = 2;
  void clear_vacancy();
  static const int kVacancyFieldNumber = 2;
  ::google::protobuf::int32 vacancy() const;
  void set_vacancy(::google::protobuf::int32 value);

  // optional float efficiency = 3;
  void clear_efficiency();
  static const int kEfficiencyFieldNumber = 3;
  float efficiency() const;
  void set_efficiency(float value);

  // @@protoc_insertion_point(class_scope:JobRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int job_type_;
  ::google::protobuf::int32 vacancy_;
  float efficiency_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_czf_2eproto();
  friend void protobuf_AssignDesc_czf_2eproto();
  friend void protobuf_ShutdownFile_czf_2eproto();

  void InitAsDefaultInstance();
  static JobRequest* default_instance_;
};
// -------------------------------------------------------------------

class PreprocessRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PreprocessRequest) */ {
 public:
  PreprocessRequest();
  virtual ~PreprocessRequest();

  PreprocessRequest(const PreprocessRequest& from);

  inline PreprocessRequest& operator=(const PreprocessRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreprocessRequest& default_instance();

  void Swap(PreprocessRequest* other);

  // implements Message ----------------------------------------------

  inline PreprocessRequest* New() const { return New(NULL); }

  PreprocessRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PreprocessRequest& from);
  void MergeFrom(const PreprocessRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PreprocessRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .GameOrigin game_origin = 1;
  bool has_game_origin() const;
  void clear_game_origin();
  static const int kGameOriginFieldNumber = 1;
  const ::GameOrigin& game_origin() const;
  ::GameOrigin* mutable_game_origin();
  ::GameOrigin* release_game_origin();
  void set_allocated_game_origin(::GameOrigin* game_origin);

  // optional bytes observation = 2;
  void clear_observation();
  static const int kObservationFieldNumber = 2;
  const ::std::string& observation() const;
  void set_observation(const ::std::string& value);
  void set_observation(const char* value);
  void set_observation(const void* value, size_t size);
  ::std::string* mutable_observation();
  ::std::string* release_observation();
  void set_allocated_observation(::std::string* observation);

  // repeated int32 legal_actions = 3;
  int legal_actions_size() const;
  void clear_legal_actions();
  static const int kLegalActionsFieldNumber = 3;
  ::google::protobuf::int32 legal_actions(int index) const;
  void set_legal_actions(int index, ::google::protobuf::int32 value);
  void add_legal_actions(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      legal_actions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_legal_actions();

  // @@protoc_insertion_point(class_scope:PreprocessRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::GameOrigin* game_origin_;
  ::google::protobuf::internal::ArenaStringPtr observation_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > legal_actions_;
  mutable int _legal_actions_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_czf_2eproto();
  friend void protobuf_AssignDesc_czf_2eproto();
  friend void protobuf_ShutdownFile_czf_2eproto();

  void InitAsDefaultInstance();
  static PreprocessRequest* default_instance_;
};
// -------------------------------------------------------------------

class SearchRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SearchRequest) */ {
 public:
  SearchRequest();
  virtual ~SearchRequest();

  SearchRequest(const SearchRequest& from);

  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchRequest& default_instance();

  void Swap(SearchRequest* other);

  // implements Message ----------------------------------------------

  inline SearchRequest* New() const { return New(NULL); }

  SearchRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchRequest& from);
  void MergeFrom(const SearchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SearchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .GameOrigin game_origin = 1;
  bool has_game_origin() const;
  void clear_game_origin();
  static const int kGameOriginFieldNumber = 1;
  const ::GameOrigin& game_origin() const;
  ::GameOrigin* mutable_game_origin();
  ::GameOrigin* release_game_origin();
  void set_allocated_game_origin(::GameOrigin* game_origin);

  // optional bytes state = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  void set_state(const char* value);
  void set_state(const void* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // repeated int32 legal_actions = 3;
  int legal_actions_size() const;
  void clear_legal_actions();
  static const int kLegalActionsFieldNumber = 3;
  ::google::protobuf::int32 legal_actions(int index) const;
  void set_legal_actions(int index, ::google::protobuf::int32 value);
  void add_legal_actions(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      legal_actions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_legal_actions();

  // @@protoc_insertion_point(class_scope:SearchRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::GameOrigin* game_origin_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > legal_actions_;
  mutable int _legal_actions_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_czf_2eproto();
  friend void protobuf_AssignDesc_czf_2eproto();
  friend void protobuf_ShutdownFile_czf_2eproto();

  void InitAsDefaultInstance();
  static SearchRequest* default_instance_;
};
// -------------------------------------------------------------------

class SearchResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SearchResponse) */ {
 public:
  SearchResponse();
  virtual ~SearchResponse();

  SearchResponse(const SearchResponse& from);

  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchResponse& default_instance();

  void Swap(SearchResponse* other);

  // implements Message ----------------------------------------------

  inline SearchResponse* New() const { return New(NULL); }

  SearchResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchResponse& from);
  void MergeFrom(const SearchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SearchResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .GameOrigin game_origin = 1;
  bool has_game_origin() const;
  void clear_game_origin();
  static const int kGameOriginFieldNumber = 1;
  const ::GameOrigin& game_origin() const;
  ::GameOrigin* mutable_game_origin();
  ::GameOrigin* release_game_origin();
  void set_allocated_game_origin(::GameOrigin* game_origin);

  // repeated .MCTSRoot mcts_roots = 2;
  int mcts_roots_size() const;
  void clear_mcts_roots();
  static const int kMctsRootsFieldNumber = 2;
  const ::MCTSRoot& mcts_roots(int index) const;
  ::MCTSRoot* mutable_mcts_roots(int index);
  ::MCTSRoot* add_mcts_roots();
  ::google::protobuf::RepeatedPtrField< ::MCTSRoot >*
      mutable_mcts_roots();
  const ::google::protobuf::RepeatedPtrField< ::MCTSRoot >&
      mcts_roots() const;

  // @@protoc_insertion_point(class_scope:SearchResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::GameOrigin* game_origin_;
  ::google::protobuf::RepeatedPtrField< ::MCTSRoot > mcts_roots_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_czf_2eproto();
  friend void protobuf_AssignDesc_czf_2eproto();
  friend void protobuf_ShutdownFile_czf_2eproto();

  void InitAsDefaultInstance();
  static SearchResponse* default_instance_;
};
// -------------------------------------------------------------------

class Trajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Trajectory) */ {
 public:
  Trajectory();
  virtual ~Trajectory();

  Trajectory(const Trajectory& from);

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trajectory& default_instance();

  void Swap(Trajectory* other);

  // implements Message ----------------------------------------------

  inline Trajectory* New() const { return New(NULL); }

  Trajectory* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Trajectory& from);
  void MergeFrom(const Trajectory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Trajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 actions = 1;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 1;
  ::google::protobuf::int32 actions(int index) const;
  void set_actions(int index, ::google::protobuf::int32 value);
  void add_actions(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      actions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_actions();

  // repeated float rewards = 2;
  int rewards_size() const;
  void clear_rewards();
  static const int kRewardsFieldNumber = 2;
  float rewards(int index) const;
  void set_rewards(int index, float value);
  void add_rewards(float value);
  const ::google::protobuf::RepeatedField< float >&
      rewards() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_rewards();

  // repeated .MCTSRoot mcts_roots = 3;
  int mcts_roots_size() const;
  void clear_mcts_roots();
  static const int kMctsRootsFieldNumber = 3;
  const ::MCTSRoot& mcts_roots(int index) const;
  ::MCTSRoot* mutable_mcts_roots(int index);
  ::MCTSRoot* add_mcts_roots();
  ::google::protobuf::RepeatedPtrField< ::MCTSRoot >*
      mutable_mcts_roots();
  const ::google::protobuf::RepeatedPtrField< ::MCTSRoot >&
      mcts_roots() const;

  // @@protoc_insertion_point(class_scope:Trajectory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > actions_;
  mutable int _actions_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > rewards_;
  mutable int _rewards_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::MCTSRoot > mcts_roots_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_czf_2eproto();
  friend void protobuf_AssignDesc_czf_2eproto();
  friend void protobuf_ShutdownFile_czf_2eproto();

  void InitAsDefaultInstance();
  static Trajectory* default_instance_;
};
// -------------------------------------------------------------------

class Packet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Packet) */ {
 public:
  Packet();
  virtual ~Packet();

  Packet(const Packet& from);

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet& default_instance();

  enum PayloadCase {
    kHeartbeat = 1,
    kJobRequest = 2,
    kPreprocessRequest = 3,
    kSearchRequest = 4,
    kSearchResponse = 5,
    kModel = 6,
    kTrajectory = 7,
    PAYLOAD_NOT_SET = 0,
  };

  void Swap(Packet* other);

  // implements Message ----------------------------------------------

  inline Packet* New() const { return New(NULL); }

  Packet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Packet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Heartbeat heartbeat = 1;
  bool has_heartbeat() const;
  void clear_heartbeat();
  static const int kHeartbeatFieldNumber = 1;
  const ::Heartbeat& heartbeat() const;
  ::Heartbeat* mutable_heartbeat();
  ::Heartbeat* release_heartbeat();
  void set_allocated_heartbeat(::Heartbeat* heartbeat);

  // optional .JobRequest job_request = 2;
  bool has_job_request() const;
  void clear_job_request();
  static const int kJobRequestFieldNumber = 2;
  const ::JobRequest& job_request() const;
  ::JobRequest* mutable_job_request();
  ::JobRequest* release_job_request();
  void set_allocated_job_request(::JobRequest* job_request);

  // optional .PreprocessRequest preprocess_request = 3;
  bool has_preprocess_request() const;
  void clear_preprocess_request();
  static const int kPreprocessRequestFieldNumber = 3;
  const ::PreprocessRequest& preprocess_request() const;
  ::PreprocessRequest* mutable_preprocess_request();
  ::PreprocessRequest* release_preprocess_request();
  void set_allocated_preprocess_request(::PreprocessRequest* preprocess_request);

  // optional .SearchRequest search_request = 4;
  bool has_search_request() const;
  void clear_search_request();
  static const int kSearchRequestFieldNumber = 4;
  const ::SearchRequest& search_request() const;
  ::SearchRequest* mutable_search_request();
  ::SearchRequest* release_search_request();
  void set_allocated_search_request(::SearchRequest* search_request);

  // optional .SearchResponse search_response = 5;
  bool has_search_response() const;
  void clear_search_response();
  static const int kSearchResponseFieldNumber = 5;
  const ::SearchResponse& search_response() const;
  ::SearchResponse* mutable_search_response();
  ::SearchResponse* release_search_response();
  void set_allocated_search_response(::SearchResponse* search_response);

  // optional .Model model = 6;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 6;
  const ::Model& model() const;
  ::Model* mutable_model();
  ::Model* release_model();
  void set_allocated_model(::Model* model);

  // optional .Trajectory trajectory = 7;
  bool has_trajectory() const;
  void clear_trajectory();
  static const int kTrajectoryFieldNumber = 7;
  const ::Trajectory& trajectory() const;
  ::Trajectory* mutable_trajectory();
  ::Trajectory* release_trajectory();
  void set_allocated_trajectory(::Trajectory* trajectory);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:Packet)
 private:
  inline void set_has_heartbeat();
  inline void set_has_job_request();
  inline void set_has_preprocess_request();
  inline void set_has_search_request();
  inline void set_has_search_response();
  inline void set_has_model();
  inline void set_has_trajectory();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union PayloadUnion {
    PayloadUnion() {}
    ::Heartbeat* heartbeat_;
    ::JobRequest* job_request_;
    ::PreprocessRequest* preprocess_request_;
    ::SearchRequest* search_request_;
    ::SearchResponse* search_response_;
    ::Model* model_;
    ::Trajectory* trajectory_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_czf_2eproto();
  friend void protobuf_AssignDesc_czf_2eproto();
  friend void protobuf_ShutdownFile_czf_2eproto();

  void InitAsDefaultInstance();
  static Packet* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// MCTSRoot

// optional float value = 1;
inline void MCTSRoot::clear_value() {
  value_ = 0;
}
inline float MCTSRoot::value() const {
  // @@protoc_insertion_point(field_get:MCTSRoot.value)
  return value_;
}
inline void MCTSRoot::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:MCTSRoot.value)
}

// repeated float policy = 2;
inline int MCTSRoot::policy_size() const {
  return policy_.size();
}
inline void MCTSRoot::clear_policy() {
  policy_.Clear();
}
inline float MCTSRoot::policy(int index) const {
  // @@protoc_insertion_point(field_get:MCTSRoot.policy)
  return policy_.Get(index);
}
inline void MCTSRoot::set_policy(int index, float value) {
  policy_.Set(index, value);
  // @@protoc_insertion_point(field_set:MCTSRoot.policy)
}
inline void MCTSRoot::add_policy(float value) {
  policy_.Add(value);
  // @@protoc_insertion_point(field_add:MCTSRoot.policy)
}
inline const ::google::protobuf::RepeatedField< float >&
MCTSRoot::policy() const {
  // @@protoc_insertion_point(field_list:MCTSRoot.policy)
  return policy_;
}
inline ::google::protobuf::RepeatedField< float >*
MCTSRoot::mutable_policy() {
  // @@protoc_insertion_point(field_mutable_list:MCTSRoot.policy)
  return &policy_;
}

// -------------------------------------------------------------------

// GameOrigin

// optional bytes node = 1;
inline void GameOrigin::clear_node() {
  node_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameOrigin::node() const {
  // @@protoc_insertion_point(field_get:GameOrigin.node)
  return node_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameOrigin::set_node(const ::std::string& value) {
  
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameOrigin.node)
}
inline void GameOrigin::set_node(const char* value) {
  
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameOrigin.node)
}
inline void GameOrigin::set_node(const void* value, size_t size) {
  
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameOrigin.node)
}
inline ::std::string* GameOrigin::mutable_node() {
  
  // @@protoc_insertion_point(field_mutable:GameOrigin.node)
  return node_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameOrigin::release_node() {
  // @@protoc_insertion_point(field_release:GameOrigin.node)
  
  return node_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameOrigin::set_allocated_node(::std::string* node) {
  if (node != NULL) {
    
  } else {
    
  }
  node_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node);
  // @@protoc_insertion_point(field_set_allocated:GameOrigin.node)
}

// optional int32 index = 2;
inline void GameOrigin::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 GameOrigin::index() const {
  // @@protoc_insertion_point(field_get:GameOrigin.index)
  return index_;
}
inline void GameOrigin::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:GameOrigin.index)
}

// -------------------------------------------------------------------

// Model

// repeated bytes blobs = 2;
inline int Model::blobs_size() const {
  return blobs_.size();
}
inline void Model::clear_blobs() {
  blobs_.Clear();
}
inline const ::std::string& Model::blobs(int index) const {
  // @@protoc_insertion_point(field_get:Model.blobs)
  return blobs_.Get(index);
}
inline ::std::string* Model::mutable_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:Model.blobs)
  return blobs_.Mutable(index);
}
inline void Model::set_blobs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Model.blobs)
  blobs_.Mutable(index)->assign(value);
}
inline void Model::set_blobs(int index, const char* value) {
  blobs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Model.blobs)
}
inline void Model::set_blobs(int index, const void* value, size_t size) {
  blobs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Model.blobs)
}
inline ::std::string* Model::add_blobs() {
  // @@protoc_insertion_point(field_add_mutable:Model.blobs)
  return blobs_.Add();
}
inline void Model::add_blobs(const ::std::string& value) {
  blobs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Model.blobs)
}
inline void Model::add_blobs(const char* value) {
  blobs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Model.blobs)
}
inline void Model::add_blobs(const void* value, size_t size) {
  blobs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Model.blobs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Model::blobs() const {
  // @@protoc_insertion_point(field_list:Model.blobs)
  return blobs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Model::mutable_blobs() {
  // @@protoc_insertion_point(field_mutable_list:Model.blobs)
  return &blobs_;
}

// -------------------------------------------------------------------

// Heartbeat

// -------------------------------------------------------------------

// JobRequest

// optional .JobType job_type = 1;
inline void JobRequest::clear_job_type() {
  job_type_ = 0;
}
inline ::JobType JobRequest::job_type() const {
  // @@protoc_insertion_point(field_get:JobRequest.job_type)
  return static_cast< ::JobType >(job_type_);
}
inline void JobRequest::set_job_type(::JobType value) {
  
  job_type_ = value;
  // @@protoc_insertion_point(field_set:JobRequest.job_type)
}

// optional int32 vacancy = 2;
inline void JobRequest::clear_vacancy() {
  vacancy_ = 0;
}
inline ::google::protobuf::int32 JobRequest::vacancy() const {
  // @@protoc_insertion_point(field_get:JobRequest.vacancy)
  return vacancy_;
}
inline void JobRequest::set_vacancy(::google::protobuf::int32 value) {
  
  vacancy_ = value;
  // @@protoc_insertion_point(field_set:JobRequest.vacancy)
}

// optional float efficiency = 3;
inline void JobRequest::clear_efficiency() {
  efficiency_ = 0;
}
inline float JobRequest::efficiency() const {
  // @@protoc_insertion_point(field_get:JobRequest.efficiency)
  return efficiency_;
}
inline void JobRequest::set_efficiency(float value) {
  
  efficiency_ = value;
  // @@protoc_insertion_point(field_set:JobRequest.efficiency)
}

// -------------------------------------------------------------------

// PreprocessRequest

// optional .GameOrigin game_origin = 1;
inline bool PreprocessRequest::has_game_origin() const {
  return !_is_default_instance_ && game_origin_ != NULL;
}
inline void PreprocessRequest::clear_game_origin() {
  if (GetArenaNoVirtual() == NULL && game_origin_ != NULL) delete game_origin_;
  game_origin_ = NULL;
}
inline const ::GameOrigin& PreprocessRequest::game_origin() const {
  // @@protoc_insertion_point(field_get:PreprocessRequest.game_origin)
  return game_origin_ != NULL ? *game_origin_ : *default_instance_->game_origin_;
}
inline ::GameOrigin* PreprocessRequest::mutable_game_origin() {
  
  if (game_origin_ == NULL) {
    game_origin_ = new ::GameOrigin;
  }
  // @@protoc_insertion_point(field_mutable:PreprocessRequest.game_origin)
  return game_origin_;
}
inline ::GameOrigin* PreprocessRequest::release_game_origin() {
  // @@protoc_insertion_point(field_release:PreprocessRequest.game_origin)
  
  ::GameOrigin* temp = game_origin_;
  game_origin_ = NULL;
  return temp;
}
inline void PreprocessRequest::set_allocated_game_origin(::GameOrigin* game_origin) {
  delete game_origin_;
  game_origin_ = game_origin;
  if (game_origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PreprocessRequest.game_origin)
}

// optional bytes observation = 2;
inline void PreprocessRequest::clear_observation() {
  observation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PreprocessRequest::observation() const {
  // @@protoc_insertion_point(field_get:PreprocessRequest.observation)
  return observation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreprocessRequest::set_observation(const ::std::string& value) {
  
  observation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PreprocessRequest.observation)
}
inline void PreprocessRequest::set_observation(const char* value) {
  
  observation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PreprocessRequest.observation)
}
inline void PreprocessRequest::set_observation(const void* value, size_t size) {
  
  observation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PreprocessRequest.observation)
}
inline ::std::string* PreprocessRequest::mutable_observation() {
  
  // @@protoc_insertion_point(field_mutable:PreprocessRequest.observation)
  return observation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PreprocessRequest::release_observation() {
  // @@protoc_insertion_point(field_release:PreprocessRequest.observation)
  
  return observation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreprocessRequest::set_allocated_observation(::std::string* observation) {
  if (observation != NULL) {
    
  } else {
    
  }
  observation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), observation);
  // @@protoc_insertion_point(field_set_allocated:PreprocessRequest.observation)
}

// repeated int32 legal_actions = 3;
inline int PreprocessRequest::legal_actions_size() const {
  return legal_actions_.size();
}
inline void PreprocessRequest::clear_legal_actions() {
  legal_actions_.Clear();
}
inline ::google::protobuf::int32 PreprocessRequest::legal_actions(int index) const {
  // @@protoc_insertion_point(field_get:PreprocessRequest.legal_actions)
  return legal_actions_.Get(index);
}
inline void PreprocessRequest::set_legal_actions(int index, ::google::protobuf::int32 value) {
  legal_actions_.Set(index, value);
  // @@protoc_insertion_point(field_set:PreprocessRequest.legal_actions)
}
inline void PreprocessRequest::add_legal_actions(::google::protobuf::int32 value) {
  legal_actions_.Add(value);
  // @@protoc_insertion_point(field_add:PreprocessRequest.legal_actions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PreprocessRequest::legal_actions() const {
  // @@protoc_insertion_point(field_list:PreprocessRequest.legal_actions)
  return legal_actions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PreprocessRequest::mutable_legal_actions() {
  // @@protoc_insertion_point(field_mutable_list:PreprocessRequest.legal_actions)
  return &legal_actions_;
}

// -------------------------------------------------------------------

// SearchRequest

// optional .GameOrigin game_origin = 1;
inline bool SearchRequest::has_game_origin() const {
  return !_is_default_instance_ && game_origin_ != NULL;
}
inline void SearchRequest::clear_game_origin() {
  if (GetArenaNoVirtual() == NULL && game_origin_ != NULL) delete game_origin_;
  game_origin_ = NULL;
}
inline const ::GameOrigin& SearchRequest::game_origin() const {
  // @@protoc_insertion_point(field_get:SearchRequest.game_origin)
  return game_origin_ != NULL ? *game_origin_ : *default_instance_->game_origin_;
}
inline ::GameOrigin* SearchRequest::mutable_game_origin() {
  
  if (game_origin_ == NULL) {
    game_origin_ = new ::GameOrigin;
  }
  // @@protoc_insertion_point(field_mutable:SearchRequest.game_origin)
  return game_origin_;
}
inline ::GameOrigin* SearchRequest::release_game_origin() {
  // @@protoc_insertion_point(field_release:SearchRequest.game_origin)
  
  ::GameOrigin* temp = game_origin_;
  game_origin_ = NULL;
  return temp;
}
inline void SearchRequest::set_allocated_game_origin(::GameOrigin* game_origin) {
  delete game_origin_;
  game_origin_ = game_origin;
  if (game_origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SearchRequest.game_origin)
}

// optional bytes state = 2;
inline void SearchRequest::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SearchRequest::state() const {
  // @@protoc_insertion_point(field_get:SearchRequest.state)
  return state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchRequest::set_state(const ::std::string& value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SearchRequest.state)
}
inline void SearchRequest::set_state(const char* value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SearchRequest.state)
}
inline void SearchRequest::set_state(const void* value, size_t size) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SearchRequest.state)
}
inline ::std::string* SearchRequest::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:SearchRequest.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SearchRequest::release_state() {
  // @@protoc_insertion_point(field_release:SearchRequest.state)
  
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchRequest::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:SearchRequest.state)
}

// repeated int32 legal_actions = 3;
inline int SearchRequest::legal_actions_size() const {
  return legal_actions_.size();
}
inline void SearchRequest::clear_legal_actions() {
  legal_actions_.Clear();
}
inline ::google::protobuf::int32 SearchRequest::legal_actions(int index) const {
  // @@protoc_insertion_point(field_get:SearchRequest.legal_actions)
  return legal_actions_.Get(index);
}
inline void SearchRequest::set_legal_actions(int index, ::google::protobuf::int32 value) {
  legal_actions_.Set(index, value);
  // @@protoc_insertion_point(field_set:SearchRequest.legal_actions)
}
inline void SearchRequest::add_legal_actions(::google::protobuf::int32 value) {
  legal_actions_.Add(value);
  // @@protoc_insertion_point(field_add:SearchRequest.legal_actions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SearchRequest::legal_actions() const {
  // @@protoc_insertion_point(field_list:SearchRequest.legal_actions)
  return legal_actions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SearchRequest::mutable_legal_actions() {
  // @@protoc_insertion_point(field_mutable_list:SearchRequest.legal_actions)
  return &legal_actions_;
}

// -------------------------------------------------------------------

// SearchResponse

// optional .GameOrigin game_origin = 1;
inline bool SearchResponse::has_game_origin() const {
  return !_is_default_instance_ && game_origin_ != NULL;
}
inline void SearchResponse::clear_game_origin() {
  if (GetArenaNoVirtual() == NULL && game_origin_ != NULL) delete game_origin_;
  game_origin_ = NULL;
}
inline const ::GameOrigin& SearchResponse::game_origin() const {
  // @@protoc_insertion_point(field_get:SearchResponse.game_origin)
  return game_origin_ != NULL ? *game_origin_ : *default_instance_->game_origin_;
}
inline ::GameOrigin* SearchResponse::mutable_game_origin() {
  
  if (game_origin_ == NULL) {
    game_origin_ = new ::GameOrigin;
  }
  // @@protoc_insertion_point(field_mutable:SearchResponse.game_origin)
  return game_origin_;
}
inline ::GameOrigin* SearchResponse::release_game_origin() {
  // @@protoc_insertion_point(field_release:SearchResponse.game_origin)
  
  ::GameOrigin* temp = game_origin_;
  game_origin_ = NULL;
  return temp;
}
inline void SearchResponse::set_allocated_game_origin(::GameOrigin* game_origin) {
  delete game_origin_;
  game_origin_ = game_origin;
  if (game_origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SearchResponse.game_origin)
}

// repeated .MCTSRoot mcts_roots = 2;
inline int SearchResponse::mcts_roots_size() const {
  return mcts_roots_.size();
}
inline void SearchResponse::clear_mcts_roots() {
  mcts_roots_.Clear();
}
inline const ::MCTSRoot& SearchResponse::mcts_roots(int index) const {
  // @@protoc_insertion_point(field_get:SearchResponse.mcts_roots)
  return mcts_roots_.Get(index);
}
inline ::MCTSRoot* SearchResponse::mutable_mcts_roots(int index) {
  // @@protoc_insertion_point(field_mutable:SearchResponse.mcts_roots)
  return mcts_roots_.Mutable(index);
}
inline ::MCTSRoot* SearchResponse::add_mcts_roots() {
  // @@protoc_insertion_point(field_add:SearchResponse.mcts_roots)
  return mcts_roots_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MCTSRoot >*
SearchResponse::mutable_mcts_roots() {
  // @@protoc_insertion_point(field_mutable_list:SearchResponse.mcts_roots)
  return &mcts_roots_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MCTSRoot >&
SearchResponse::mcts_roots() const {
  // @@protoc_insertion_point(field_list:SearchResponse.mcts_roots)
  return mcts_roots_;
}

// -------------------------------------------------------------------

// Trajectory

// repeated int32 actions = 1;
inline int Trajectory::actions_size() const {
  return actions_.size();
}
inline void Trajectory::clear_actions() {
  actions_.Clear();
}
inline ::google::protobuf::int32 Trajectory::actions(int index) const {
  // @@protoc_insertion_point(field_get:Trajectory.actions)
  return actions_.Get(index);
}
inline void Trajectory::set_actions(int index, ::google::protobuf::int32 value) {
  actions_.Set(index, value);
  // @@protoc_insertion_point(field_set:Trajectory.actions)
}
inline void Trajectory::add_actions(::google::protobuf::int32 value) {
  actions_.Add(value);
  // @@protoc_insertion_point(field_add:Trajectory.actions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Trajectory::actions() const {
  // @@protoc_insertion_point(field_list:Trajectory.actions)
  return actions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Trajectory::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:Trajectory.actions)
  return &actions_;
}

// repeated float rewards = 2;
inline int Trajectory::rewards_size() const {
  return rewards_.size();
}
inline void Trajectory::clear_rewards() {
  rewards_.Clear();
}
inline float Trajectory::rewards(int index) const {
  // @@protoc_insertion_point(field_get:Trajectory.rewards)
  return rewards_.Get(index);
}
inline void Trajectory::set_rewards(int index, float value) {
  rewards_.Set(index, value);
  // @@protoc_insertion_point(field_set:Trajectory.rewards)
}
inline void Trajectory::add_rewards(float value) {
  rewards_.Add(value);
  // @@protoc_insertion_point(field_add:Trajectory.rewards)
}
inline const ::google::protobuf::RepeatedField< float >&
Trajectory::rewards() const {
  // @@protoc_insertion_point(field_list:Trajectory.rewards)
  return rewards_;
}
inline ::google::protobuf::RepeatedField< float >*
Trajectory::mutable_rewards() {
  // @@protoc_insertion_point(field_mutable_list:Trajectory.rewards)
  return &rewards_;
}

// repeated .MCTSRoot mcts_roots = 3;
inline int Trajectory::mcts_roots_size() const {
  return mcts_roots_.size();
}
inline void Trajectory::clear_mcts_roots() {
  mcts_roots_.Clear();
}
inline const ::MCTSRoot& Trajectory::mcts_roots(int index) const {
  // @@protoc_insertion_point(field_get:Trajectory.mcts_roots)
  return mcts_roots_.Get(index);
}
inline ::MCTSRoot* Trajectory::mutable_mcts_roots(int index) {
  // @@protoc_insertion_point(field_mutable:Trajectory.mcts_roots)
  return mcts_roots_.Mutable(index);
}
inline ::MCTSRoot* Trajectory::add_mcts_roots() {
  // @@protoc_insertion_point(field_add:Trajectory.mcts_roots)
  return mcts_roots_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MCTSRoot >*
Trajectory::mutable_mcts_roots() {
  // @@protoc_insertion_point(field_mutable_list:Trajectory.mcts_roots)
  return &mcts_roots_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MCTSRoot >&
Trajectory::mcts_roots() const {
  // @@protoc_insertion_point(field_list:Trajectory.mcts_roots)
  return mcts_roots_;
}

// -------------------------------------------------------------------

// Packet

// optional .Heartbeat heartbeat = 1;
inline bool Packet::has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline void Packet::set_has_heartbeat() {
  _oneof_case_[0] = kHeartbeat;
}
inline void Packet::clear_heartbeat() {
  if (has_heartbeat()) {
    delete payload_.heartbeat_;
    clear_has_payload();
  }
}
inline  const ::Heartbeat& Packet::heartbeat() const {
  // @@protoc_insertion_point(field_get:Packet.heartbeat)
  return has_heartbeat()
      ? *payload_.heartbeat_
      : ::Heartbeat::default_instance();
}
inline ::Heartbeat* Packet::mutable_heartbeat() {
  if (!has_heartbeat()) {
    clear_payload();
    set_has_heartbeat();
    payload_.heartbeat_ = new ::Heartbeat;
  }
  // @@protoc_insertion_point(field_mutable:Packet.heartbeat)
  return payload_.heartbeat_;
}
inline ::Heartbeat* Packet::release_heartbeat() {
  // @@protoc_insertion_point(field_release:Packet.heartbeat)
  if (has_heartbeat()) {
    clear_has_payload();
    ::Heartbeat* temp = payload_.heartbeat_;
    payload_.heartbeat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_heartbeat(::Heartbeat* heartbeat) {
  clear_payload();
  if (heartbeat) {
    set_has_heartbeat();
    payload_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_set_allocated:Packet.heartbeat)
}

// optional .JobRequest job_request = 2;
inline bool Packet::has_job_request() const {
  return payload_case() == kJobRequest;
}
inline void Packet::set_has_job_request() {
  _oneof_case_[0] = kJobRequest;
}
inline void Packet::clear_job_request() {
  if (has_job_request()) {
    delete payload_.job_request_;
    clear_has_payload();
  }
}
inline  const ::JobRequest& Packet::job_request() const {
  // @@protoc_insertion_point(field_get:Packet.job_request)
  return has_job_request()
      ? *payload_.job_request_
      : ::JobRequest::default_instance();
}
inline ::JobRequest* Packet::mutable_job_request() {
  if (!has_job_request()) {
    clear_payload();
    set_has_job_request();
    payload_.job_request_ = new ::JobRequest;
  }
  // @@protoc_insertion_point(field_mutable:Packet.job_request)
  return payload_.job_request_;
}
inline ::JobRequest* Packet::release_job_request() {
  // @@protoc_insertion_point(field_release:Packet.job_request)
  if (has_job_request()) {
    clear_has_payload();
    ::JobRequest* temp = payload_.job_request_;
    payload_.job_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_job_request(::JobRequest* job_request) {
  clear_payload();
  if (job_request) {
    set_has_job_request();
    payload_.job_request_ = job_request;
  }
  // @@protoc_insertion_point(field_set_allocated:Packet.job_request)
}

// optional .PreprocessRequest preprocess_request = 3;
inline bool Packet::has_preprocess_request() const {
  return payload_case() == kPreprocessRequest;
}
inline void Packet::set_has_preprocess_request() {
  _oneof_case_[0] = kPreprocessRequest;
}
inline void Packet::clear_preprocess_request() {
  if (has_preprocess_request()) {
    delete payload_.preprocess_request_;
    clear_has_payload();
  }
}
inline  const ::PreprocessRequest& Packet::preprocess_request() const {
  // @@protoc_insertion_point(field_get:Packet.preprocess_request)
  return has_preprocess_request()
      ? *payload_.preprocess_request_
      : ::PreprocessRequest::default_instance();
}
inline ::PreprocessRequest* Packet::mutable_preprocess_request() {
  if (!has_preprocess_request()) {
    clear_payload();
    set_has_preprocess_request();
    payload_.preprocess_request_ = new ::PreprocessRequest;
  }
  // @@protoc_insertion_point(field_mutable:Packet.preprocess_request)
  return payload_.preprocess_request_;
}
inline ::PreprocessRequest* Packet::release_preprocess_request() {
  // @@protoc_insertion_point(field_release:Packet.preprocess_request)
  if (has_preprocess_request()) {
    clear_has_payload();
    ::PreprocessRequest* temp = payload_.preprocess_request_;
    payload_.preprocess_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_preprocess_request(::PreprocessRequest* preprocess_request) {
  clear_payload();
  if (preprocess_request) {
    set_has_preprocess_request();
    payload_.preprocess_request_ = preprocess_request;
  }
  // @@protoc_insertion_point(field_set_allocated:Packet.preprocess_request)
}

// optional .SearchRequest search_request = 4;
inline bool Packet::has_search_request() const {
  return payload_case() == kSearchRequest;
}
inline void Packet::set_has_search_request() {
  _oneof_case_[0] = kSearchRequest;
}
inline void Packet::clear_search_request() {
  if (has_search_request()) {
    delete payload_.search_request_;
    clear_has_payload();
  }
}
inline  const ::SearchRequest& Packet::search_request() const {
  // @@protoc_insertion_point(field_get:Packet.search_request)
  return has_search_request()
      ? *payload_.search_request_
      : ::SearchRequest::default_instance();
}
inline ::SearchRequest* Packet::mutable_search_request() {
  if (!has_search_request()) {
    clear_payload();
    set_has_search_request();
    payload_.search_request_ = new ::SearchRequest;
  }
  // @@protoc_insertion_point(field_mutable:Packet.search_request)
  return payload_.search_request_;
}
inline ::SearchRequest* Packet::release_search_request() {
  // @@protoc_insertion_point(field_release:Packet.search_request)
  if (has_search_request()) {
    clear_has_payload();
    ::SearchRequest* temp = payload_.search_request_;
    payload_.search_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_search_request(::SearchRequest* search_request) {
  clear_payload();
  if (search_request) {
    set_has_search_request();
    payload_.search_request_ = search_request;
  }
  // @@protoc_insertion_point(field_set_allocated:Packet.search_request)
}

// optional .SearchResponse search_response = 5;
inline bool Packet::has_search_response() const {
  return payload_case() == kSearchResponse;
}
inline void Packet::set_has_search_response() {
  _oneof_case_[0] = kSearchResponse;
}
inline void Packet::clear_search_response() {
  if (has_search_response()) {
    delete payload_.search_response_;
    clear_has_payload();
  }
}
inline  const ::SearchResponse& Packet::search_response() const {
  // @@protoc_insertion_point(field_get:Packet.search_response)
  return has_search_response()
      ? *payload_.search_response_
      : ::SearchResponse::default_instance();
}
inline ::SearchResponse* Packet::mutable_search_response() {
  if (!has_search_response()) {
    clear_payload();
    set_has_search_response();
    payload_.search_response_ = new ::SearchResponse;
  }
  // @@protoc_insertion_point(field_mutable:Packet.search_response)
  return payload_.search_response_;
}
inline ::SearchResponse* Packet::release_search_response() {
  // @@protoc_insertion_point(field_release:Packet.search_response)
  if (has_search_response()) {
    clear_has_payload();
    ::SearchResponse* temp = payload_.search_response_;
    payload_.search_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_search_response(::SearchResponse* search_response) {
  clear_payload();
  if (search_response) {
    set_has_search_response();
    payload_.search_response_ = search_response;
  }
  // @@protoc_insertion_point(field_set_allocated:Packet.search_response)
}

// optional .Model model = 6;
inline bool Packet::has_model() const {
  return payload_case() == kModel;
}
inline void Packet::set_has_model() {
  _oneof_case_[0] = kModel;
}
inline void Packet::clear_model() {
  if (has_model()) {
    delete payload_.model_;
    clear_has_payload();
  }
}
inline  const ::Model& Packet::model() const {
  // @@protoc_insertion_point(field_get:Packet.model)
  return has_model()
      ? *payload_.model_
      : ::Model::default_instance();
}
inline ::Model* Packet::mutable_model() {
  if (!has_model()) {
    clear_payload();
    set_has_model();
    payload_.model_ = new ::Model;
  }
  // @@protoc_insertion_point(field_mutable:Packet.model)
  return payload_.model_;
}
inline ::Model* Packet::release_model() {
  // @@protoc_insertion_point(field_release:Packet.model)
  if (has_model()) {
    clear_has_payload();
    ::Model* temp = payload_.model_;
    payload_.model_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_model(::Model* model) {
  clear_payload();
  if (model) {
    set_has_model();
    payload_.model_ = model;
  }
  // @@protoc_insertion_point(field_set_allocated:Packet.model)
}

// optional .Trajectory trajectory = 7;
inline bool Packet::has_trajectory() const {
  return payload_case() == kTrajectory;
}
inline void Packet::set_has_trajectory() {
  _oneof_case_[0] = kTrajectory;
}
inline void Packet::clear_trajectory() {
  if (has_trajectory()) {
    delete payload_.trajectory_;
    clear_has_payload();
  }
}
inline  const ::Trajectory& Packet::trajectory() const {
  // @@protoc_insertion_point(field_get:Packet.trajectory)
  return has_trajectory()
      ? *payload_.trajectory_
      : ::Trajectory::default_instance();
}
inline ::Trajectory* Packet::mutable_trajectory() {
  if (!has_trajectory()) {
    clear_payload();
    set_has_trajectory();
    payload_.trajectory_ = new ::Trajectory;
  }
  // @@protoc_insertion_point(field_mutable:Packet.trajectory)
  return payload_.trajectory_;
}
inline ::Trajectory* Packet::release_trajectory() {
  // @@protoc_insertion_point(field_release:Packet.trajectory)
  if (has_trajectory()) {
    clear_has_payload();
    ::Trajectory* temp = payload_.trajectory_;
    payload_.trajectory_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_trajectory(::Trajectory* trajectory) {
  clear_payload();
  if (trajectory) {
    set_has_trajectory();
    payload_.trajectory_ = trajectory;
  }
  // @@protoc_insertion_point(field_set_allocated:Packet.trajectory)
}

inline bool Packet::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Packet::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Packet::PayloadCase Packet::payload_case() const {
  return Packet::PayloadCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::JobType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::JobType>() {
  return ::JobType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_czf_2eproto__INCLUDED
