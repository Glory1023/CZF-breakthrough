// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: czf.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_czf_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_czf_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_czf_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_czf_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_czf_2eproto;
class GameOrigin;
class GameOriginDefaultTypeInternal;
extern GameOriginDefaultTypeInternal _GameOrigin_default_instance_;
class Heartbeat;
class HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class JobRequest;
class JobRequestDefaultTypeInternal;
extern JobRequestDefaultTypeInternal _JobRequest_default_instance_;
class MCTSRoot;
class MCTSRootDefaultTypeInternal;
extern MCTSRootDefaultTypeInternal _MCTSRoot_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Packet;
class PacketDefaultTypeInternal;
extern PacketDefaultTypeInternal _Packet_default_instance_;
class PreprocessRequest;
class PreprocessRequestDefaultTypeInternal;
extern PreprocessRequestDefaultTypeInternal _PreprocessRequest_default_instance_;
class SearchRequest;
class SearchRequestDefaultTypeInternal;
extern SearchRequestDefaultTypeInternal _SearchRequest_default_instance_;
class SearchResponse;
class SearchResponseDefaultTypeInternal;
extern SearchResponseDefaultTypeInternal _SearchResponse_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::GameOrigin* Arena::CreateMaybeMessage<::GameOrigin>(Arena*);
template<> ::Heartbeat* Arena::CreateMaybeMessage<::Heartbeat>(Arena*);
template<> ::JobRequest* Arena::CreateMaybeMessage<::JobRequest>(Arena*);
template<> ::MCTSRoot* Arena::CreateMaybeMessage<::MCTSRoot>(Arena*);
template<> ::Model* Arena::CreateMaybeMessage<::Model>(Arena*);
template<> ::Packet* Arena::CreateMaybeMessage<::Packet>(Arena*);
template<> ::PreprocessRequest* Arena::CreateMaybeMessage<::PreprocessRequest>(Arena*);
template<> ::SearchRequest* Arena::CreateMaybeMessage<::SearchRequest>(Arena*);
template<> ::SearchResponse* Arena::CreateMaybeMessage<::SearchResponse>(Arena*);
template<> ::Trajectory* Arena::CreateMaybeMessage<::Trajectory>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum JobType : int {
  UNKNOWN = 0,
  PREPROCESS = 1,
  SEARCH = 2,
  JobType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  JobType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool JobType_IsValid(int value);
constexpr JobType JobType_MIN = UNKNOWN;
constexpr JobType JobType_MAX = SEARCH;
constexpr int JobType_ARRAYSIZE = JobType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JobType_descriptor();
template<typename T>
inline const std::string& JobType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JobType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JobType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JobType_descriptor(), enum_t_value);
}
inline bool JobType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JobType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JobType>(
    JobType_descriptor(), name, value);
}
// ===================================================================

class MCTSRoot PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MCTSRoot) */ {
 public:
  inline MCTSRoot() : MCTSRoot(nullptr) {};
  virtual ~MCTSRoot();

  MCTSRoot(const MCTSRoot& from);
  MCTSRoot(MCTSRoot&& from) noexcept
    : MCTSRoot() {
    *this = ::std::move(from);
  }

  inline MCTSRoot& operator=(const MCTSRoot& from) {
    CopyFrom(from);
    return *this;
  }
  inline MCTSRoot& operator=(MCTSRoot&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MCTSRoot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MCTSRoot* internal_default_instance() {
    return reinterpret_cast<const MCTSRoot*>(
               &_MCTSRoot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MCTSRoot& a, MCTSRoot& b) {
    a.Swap(&b);
  }
  inline void Swap(MCTSRoot* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MCTSRoot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MCTSRoot* New() const final {
    return CreateMaybeMessage<MCTSRoot>(nullptr);
  }

  MCTSRoot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MCTSRoot>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MCTSRoot& from);
  void MergeFrom(const MCTSRoot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MCTSRoot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MCTSRoot";
  }
  protected:
  explicit MCTSRoot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_czf_2eproto);
    return ::descriptor_table_czf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 2,
    kValueFieldNumber = 1,
  };
  // repeated float policy = 2;
  int policy_size() const;
  private:
  int _internal_policy_size() const;
  public:
  void clear_policy();
  private:
  float _internal_policy(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_policy() const;
  void _internal_add_policy(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_policy();
  public:
  float policy(int index) const;
  void set_policy(int index, float value);
  void add_policy(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      policy() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_policy();

  // float value = 1;
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:MCTSRoot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > policy_;
  mutable std::atomic<int> _policy_cached_byte_size_;
  float value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_czf_2eproto;
};
// -------------------------------------------------------------------

class GameOrigin PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameOrigin) */ {
 public:
  inline GameOrigin() : GameOrigin(nullptr) {};
  virtual ~GameOrigin();

  GameOrigin(const GameOrigin& from);
  GameOrigin(GameOrigin&& from) noexcept
    : GameOrigin() {
    *this = ::std::move(from);
  }

  inline GameOrigin& operator=(const GameOrigin& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameOrigin& operator=(GameOrigin&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameOrigin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameOrigin* internal_default_instance() {
    return reinterpret_cast<const GameOrigin*>(
               &_GameOrigin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GameOrigin& a, GameOrigin& b) {
    a.Swap(&b);
  }
  inline void Swap(GameOrigin* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameOrigin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameOrigin* New() const final {
    return CreateMaybeMessage<GameOrigin>(nullptr);
  }

  GameOrigin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameOrigin>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameOrigin& from);
  void MergeFrom(const GameOrigin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameOrigin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameOrigin";
  }
  protected:
  explicit GameOrigin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_czf_2eproto);
    return ::descriptor_table_czf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // bytes node = 1;
  void clear_node();
  const std::string& node() const;
  void set_node(const std::string& value);
  void set_node(std::string&& value);
  void set_node(const char* value);
  void set_node(const void* value, size_t size);
  std::string* mutable_node();
  std::string* release_node();
  void set_allocated_node(std::string* node);
  private:
  const std::string& _internal_node() const;
  void _internal_set_node(const std::string& value);
  std::string* _internal_mutable_node();
  public:

  // int32 index = 2;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::int32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:GameOrigin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_;
  ::PROTOBUF_NAMESPACE_ID::int32 index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_czf_2eproto;
};
// -------------------------------------------------------------------

class Model PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Model) */ {
 public:
  inline Model() : Model(nullptr) {};
  virtual ~Model();

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const final {
    return CreateMaybeMessage<Model>(nullptr);
  }

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_czf_2eproto);
    return ::descriptor_table_czf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobsFieldNumber = 2,
  };
  // repeated bytes blobs = 2;
  int blobs_size() const;
  private:
  int _internal_blobs_size() const;
  public:
  void clear_blobs();
  const std::string& blobs(int index) const;
  std::string* mutable_blobs(int index);
  void set_blobs(int index, const std::string& value);
  void set_blobs(int index, std::string&& value);
  void set_blobs(int index, const char* value);
  void set_blobs(int index, const void* value, size_t size);
  std::string* add_blobs();
  void add_blobs(const std::string& value);
  void add_blobs(std::string&& value);
  void add_blobs(const char* value);
  void add_blobs(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& blobs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_blobs();
  private:
  const std::string& _internal_blobs(int index) const;
  std::string* _internal_add_blobs();
  public:

  // @@protoc_insertion_point(class_scope:Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> blobs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_czf_2eproto;
};
// -------------------------------------------------------------------

class Heartbeat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {};
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);
  Heartbeat(Heartbeat&& from) noexcept
    : Heartbeat() {
    *this = ::std::move(from);
  }

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Heartbeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
               &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Heartbeat& a, Heartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Heartbeat* New() const final {
    return CreateMaybeMessage<Heartbeat>(nullptr);
  }

  Heartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Heartbeat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Heartbeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Heartbeat";
  }
  protected:
  explicit Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_czf_2eproto);
    return ::descriptor_table_czf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Heartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_czf_2eproto;
};
// -------------------------------------------------------------------

class JobRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JobRequest) */ {
 public:
  inline JobRequest() : JobRequest(nullptr) {};
  virtual ~JobRequest();

  JobRequest(const JobRequest& from);
  JobRequest(JobRequest&& from) noexcept
    : JobRequest() {
    *this = ::std::move(from);
  }

  inline JobRequest& operator=(const JobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobRequest& operator=(JobRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JobRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JobRequest* internal_default_instance() {
    return reinterpret_cast<const JobRequest*>(
               &_JobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JobRequest& a, JobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JobRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JobRequest* New() const final {
    return CreateMaybeMessage<JobRequest>(nullptr);
  }

  JobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JobRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JobRequest& from);
  void MergeFrom(const JobRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JobRequest";
  }
  protected:
  explicit JobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_czf_2eproto);
    return ::descriptor_table_czf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobTypeFieldNumber = 1,
    kVacancyFieldNumber = 2,
    kEfficiencyFieldNumber = 3,
  };
  // .JobType job_type = 1;
  void clear_job_type();
  ::JobType job_type() const;
  void set_job_type(::JobType value);
  private:
  ::JobType _internal_job_type() const;
  void _internal_set_job_type(::JobType value);
  public:

  // int32 vacancy = 2;
  void clear_vacancy();
  ::PROTOBUF_NAMESPACE_ID::int32 vacancy() const;
  void set_vacancy(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vacancy() const;
  void _internal_set_vacancy(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float efficiency = 3;
  void clear_efficiency();
  float efficiency() const;
  void set_efficiency(float value);
  private:
  float _internal_efficiency() const;
  void _internal_set_efficiency(float value);
  public:

  // @@protoc_insertion_point(class_scope:JobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int job_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 vacancy_;
  float efficiency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_czf_2eproto;
};
// -------------------------------------------------------------------

class PreprocessRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PreprocessRequest) */ {
 public:
  inline PreprocessRequest() : PreprocessRequest(nullptr) {};
  virtual ~PreprocessRequest();

  PreprocessRequest(const PreprocessRequest& from);
  PreprocessRequest(PreprocessRequest&& from) noexcept
    : PreprocessRequest() {
    *this = ::std::move(from);
  }

  inline PreprocessRequest& operator=(const PreprocessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreprocessRequest& operator=(PreprocessRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PreprocessRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PreprocessRequest* internal_default_instance() {
    return reinterpret_cast<const PreprocessRequest*>(
               &_PreprocessRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PreprocessRequest& a, PreprocessRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PreprocessRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreprocessRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PreprocessRequest* New() const final {
    return CreateMaybeMessage<PreprocessRequest>(nullptr);
  }

  PreprocessRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PreprocessRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PreprocessRequest& from);
  void MergeFrom(const PreprocessRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreprocessRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PreprocessRequest";
  }
  protected:
  explicit PreprocessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_czf_2eproto);
    return ::descriptor_table_czf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegalActionsFieldNumber = 3,
    kObservationFieldNumber = 2,
    kGameOriginFieldNumber = 1,
  };
  // repeated int32 legal_actions = 3;
  int legal_actions_size() const;
  private:
  int _internal_legal_actions_size() const;
  public:
  void clear_legal_actions();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_legal_actions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_legal_actions() const;
  void _internal_add_legal_actions(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_legal_actions();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 legal_actions(int index) const;
  void set_legal_actions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_legal_actions(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      legal_actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_legal_actions();

  // bytes observation = 2;
  void clear_observation();
  const std::string& observation() const;
  void set_observation(const std::string& value);
  void set_observation(std::string&& value);
  void set_observation(const char* value);
  void set_observation(const void* value, size_t size);
  std::string* mutable_observation();
  std::string* release_observation();
  void set_allocated_observation(std::string* observation);
  private:
  const std::string& _internal_observation() const;
  void _internal_set_observation(const std::string& value);
  std::string* _internal_mutable_observation();
  public:

  // .GameOrigin game_origin = 1;
  bool has_game_origin() const;
  private:
  bool _internal_has_game_origin() const;
  public:
  void clear_game_origin();
  const ::GameOrigin& game_origin() const;
  ::GameOrigin* release_game_origin();
  ::GameOrigin* mutable_game_origin();
  void set_allocated_game_origin(::GameOrigin* game_origin);
  private:
  const ::GameOrigin& _internal_game_origin() const;
  ::GameOrigin* _internal_mutable_game_origin();
  public:
  void unsafe_arena_set_allocated_game_origin(
      ::GameOrigin* game_origin);
  ::GameOrigin* unsafe_arena_release_game_origin();

  // @@protoc_insertion_point(class_scope:PreprocessRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > legal_actions_;
  mutable std::atomic<int> _legal_actions_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr observation_;
  ::GameOrigin* game_origin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_czf_2eproto;
};
// -------------------------------------------------------------------

class SearchRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SearchRequest) */ {
 public:
  inline SearchRequest() : SearchRequest(nullptr) {};
  virtual ~SearchRequest();

  SearchRequest(const SearchRequest& from);
  SearchRequest(SearchRequest&& from) noexcept
    : SearchRequest() {
    *this = ::std::move(from);
  }

  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchRequest& operator=(SearchRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SearchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchRequest* internal_default_instance() {
    return reinterpret_cast<const SearchRequest*>(
               &_SearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SearchRequest& a, SearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchRequest* New() const final {
    return CreateMaybeMessage<SearchRequest>(nullptr);
  }

  SearchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SearchRequest& from);
  void MergeFrom(const SearchRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SearchRequest";
  }
  protected:
  explicit SearchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_czf_2eproto);
    return ::descriptor_table_czf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegalActionsFieldNumber = 3,
    kStateFieldNumber = 2,
    kGameOriginFieldNumber = 1,
  };
  // repeated int32 legal_actions = 3;
  int legal_actions_size() const;
  private:
  int _internal_legal_actions_size() const;
  public:
  void clear_legal_actions();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_legal_actions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_legal_actions() const;
  void _internal_add_legal_actions(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_legal_actions();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 legal_actions(int index) const;
  void set_legal_actions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_legal_actions(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      legal_actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_legal_actions();

  // bytes state = 2;
  void clear_state();
  const std::string& state() const;
  void set_state(const std::string& value);
  void set_state(std::string&& value);
  void set_state(const char* value);
  void set_state(const void* value, size_t size);
  std::string* mutable_state();
  std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // .GameOrigin game_origin = 1;
  bool has_game_origin() const;
  private:
  bool _internal_has_game_origin() const;
  public:
  void clear_game_origin();
  const ::GameOrigin& game_origin() const;
  ::GameOrigin* release_game_origin();
  ::GameOrigin* mutable_game_origin();
  void set_allocated_game_origin(::GameOrigin* game_origin);
  private:
  const ::GameOrigin& _internal_game_origin() const;
  ::GameOrigin* _internal_mutable_game_origin();
  public:
  void unsafe_arena_set_allocated_game_origin(
      ::GameOrigin* game_origin);
  ::GameOrigin* unsafe_arena_release_game_origin();

  // @@protoc_insertion_point(class_scope:SearchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > legal_actions_;
  mutable std::atomic<int> _legal_actions_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::GameOrigin* game_origin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_czf_2eproto;
};
// -------------------------------------------------------------------

class SearchResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SearchResponse) */ {
 public:
  inline SearchResponse() : SearchResponse(nullptr) {};
  virtual ~SearchResponse();

  SearchResponse(const SearchResponse& from);
  SearchResponse(SearchResponse&& from) noexcept
    : SearchResponse() {
    *this = ::std::move(from);
  }

  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResponse& operator=(SearchResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SearchResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchResponse* internal_default_instance() {
    return reinterpret_cast<const SearchResponse*>(
               &_SearchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SearchResponse& a, SearchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchResponse* New() const final {
    return CreateMaybeMessage<SearchResponse>(nullptr);
  }

  SearchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SearchResponse& from);
  void MergeFrom(const SearchResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SearchResponse";
  }
  protected:
  explicit SearchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_czf_2eproto);
    return ::descriptor_table_czf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMctsRootsFieldNumber = 2,
    kGameOriginFieldNumber = 1,
  };
  // repeated .MCTSRoot mcts_roots = 2;
  int mcts_roots_size() const;
  private:
  int _internal_mcts_roots_size() const;
  public:
  void clear_mcts_roots();
  ::MCTSRoot* mutable_mcts_roots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MCTSRoot >*
      mutable_mcts_roots();
  private:
  const ::MCTSRoot& _internal_mcts_roots(int index) const;
  ::MCTSRoot* _internal_add_mcts_roots();
  public:
  const ::MCTSRoot& mcts_roots(int index) const;
  ::MCTSRoot* add_mcts_roots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MCTSRoot >&
      mcts_roots() const;

  // .GameOrigin game_origin = 1;
  bool has_game_origin() const;
  private:
  bool _internal_has_game_origin() const;
  public:
  void clear_game_origin();
  const ::GameOrigin& game_origin() const;
  ::GameOrigin* release_game_origin();
  ::GameOrigin* mutable_game_origin();
  void set_allocated_game_origin(::GameOrigin* game_origin);
  private:
  const ::GameOrigin& _internal_game_origin() const;
  ::GameOrigin* _internal_mutable_game_origin();
  public:
  void unsafe_arena_set_allocated_game_origin(
      ::GameOrigin* game_origin);
  ::GameOrigin* unsafe_arena_release_game_origin();

  // @@protoc_insertion_point(class_scope:SearchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MCTSRoot > mcts_roots_;
  ::GameOrigin* game_origin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_czf_2eproto;
};
// -------------------------------------------------------------------

class Trajectory PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Trajectory) */ {
 public:
  inline Trajectory() : Trajectory(nullptr) {};
  virtual ~Trajectory();

  Trajectory(const Trajectory& from);
  Trajectory(Trajectory&& from) noexcept
    : Trajectory() {
    *this = ::std::move(from);
  }

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trajectory& operator=(Trajectory&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Trajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trajectory* internal_default_instance() {
    return reinterpret_cast<const Trajectory*>(
               &_Trajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Trajectory& a, Trajectory& b) {
    a.Swap(&b);
  }
  inline void Swap(Trajectory* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trajectory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Trajectory* New() const final {
    return CreateMaybeMessage<Trajectory>(nullptr);
  }

  Trajectory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Trajectory>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Trajectory& from);
  void MergeFrom(const Trajectory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trajectory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Trajectory";
  }
  protected:
  explicit Trajectory(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_czf_2eproto);
    return ::descriptor_table_czf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
    kRewardsFieldNumber = 2,
    kMctsRootsFieldNumber = 3,
  };
  // repeated int32 actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_actions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_actions() const;
  void _internal_add_actions(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_actions();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 actions(int index) const;
  void set_actions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_actions(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_actions();

  // repeated float rewards = 2;
  int rewards_size() const;
  private:
  int _internal_rewards_size() const;
  public:
  void clear_rewards();
  private:
  float _internal_rewards(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_rewards() const;
  void _internal_add_rewards(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_rewards();
  public:
  float rewards(int index) const;
  void set_rewards(int index, float value);
  void add_rewards(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      rewards() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_rewards();

  // repeated .MCTSRoot mcts_roots = 3;
  int mcts_roots_size() const;
  private:
  int _internal_mcts_roots_size() const;
  public:
  void clear_mcts_roots();
  ::MCTSRoot* mutable_mcts_roots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MCTSRoot >*
      mutable_mcts_roots();
  private:
  const ::MCTSRoot& _internal_mcts_roots(int index) const;
  ::MCTSRoot* _internal_add_mcts_roots();
  public:
  const ::MCTSRoot& mcts_roots(int index) const;
  ::MCTSRoot* add_mcts_roots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MCTSRoot >&
      mcts_roots() const;

  // @@protoc_insertion_point(class_scope:Trajectory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > actions_;
  mutable std::atomic<int> _actions_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > rewards_;
  mutable std::atomic<int> _rewards_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MCTSRoot > mcts_roots_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_czf_2eproto;
};
// -------------------------------------------------------------------

class Packet PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Packet) */ {
 public:
  inline Packet() : Packet(nullptr) {};
  virtual ~Packet();

  Packet(const Packet& from);
  Packet(Packet&& from) noexcept
    : Packet() {
    *this = ::std::move(from);
  }

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Packet& operator=(Packet&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Packet& default_instance();

  enum PayloadCase {
    kHeartbeat = 1,
    kJobRequest = 2,
    kPreprocessRequest = 3,
    kSearchRequest = 4,
    kSearchResponse = 5,
    kModel = 6,
    kTrajectory = 7,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Packet* internal_default_instance() {
    return reinterpret_cast<const Packet*>(
               &_Packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Packet& a, Packet& b) {
    a.Swap(&b);
  }
  inline void Swap(Packet* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Packet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Packet* New() const final {
    return CreateMaybeMessage<Packet>(nullptr);
  }

  Packet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Packet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Packet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Packet";
  }
  protected:
  explicit Packet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_czf_2eproto);
    return ::descriptor_table_czf_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeartbeatFieldNumber = 1,
    kJobRequestFieldNumber = 2,
    kPreprocessRequestFieldNumber = 3,
    kSearchRequestFieldNumber = 4,
    kSearchResponseFieldNumber = 5,
    kModelFieldNumber = 6,
    kTrajectoryFieldNumber = 7,
  };
  // .Heartbeat heartbeat = 1;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;
  public:
  void clear_heartbeat();
  const ::Heartbeat& heartbeat() const;
  ::Heartbeat* release_heartbeat();
  ::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::Heartbeat* heartbeat);
  private:
  const ::Heartbeat& _internal_heartbeat() const;
  ::Heartbeat* _internal_mutable_heartbeat();
  public:
  void unsafe_arena_set_allocated_heartbeat(
      ::Heartbeat* heartbeat);
  ::Heartbeat* unsafe_arena_release_heartbeat();

  // .JobRequest job_request = 2;
  bool has_job_request() const;
  private:
  bool _internal_has_job_request() const;
  public:
  void clear_job_request();
  const ::JobRequest& job_request() const;
  ::JobRequest* release_job_request();
  ::JobRequest* mutable_job_request();
  void set_allocated_job_request(::JobRequest* job_request);
  private:
  const ::JobRequest& _internal_job_request() const;
  ::JobRequest* _internal_mutable_job_request();
  public:
  void unsafe_arena_set_allocated_job_request(
      ::JobRequest* job_request);
  ::JobRequest* unsafe_arena_release_job_request();

  // .PreprocessRequest preprocess_request = 3;
  bool has_preprocess_request() const;
  private:
  bool _internal_has_preprocess_request() const;
  public:
  void clear_preprocess_request();
  const ::PreprocessRequest& preprocess_request() const;
  ::PreprocessRequest* release_preprocess_request();
  ::PreprocessRequest* mutable_preprocess_request();
  void set_allocated_preprocess_request(::PreprocessRequest* preprocess_request);
  private:
  const ::PreprocessRequest& _internal_preprocess_request() const;
  ::PreprocessRequest* _internal_mutable_preprocess_request();
  public:
  void unsafe_arena_set_allocated_preprocess_request(
      ::PreprocessRequest* preprocess_request);
  ::PreprocessRequest* unsafe_arena_release_preprocess_request();

  // .SearchRequest search_request = 4;
  bool has_search_request() const;
  private:
  bool _internal_has_search_request() const;
  public:
  void clear_search_request();
  const ::SearchRequest& search_request() const;
  ::SearchRequest* release_search_request();
  ::SearchRequest* mutable_search_request();
  void set_allocated_search_request(::SearchRequest* search_request);
  private:
  const ::SearchRequest& _internal_search_request() const;
  ::SearchRequest* _internal_mutable_search_request();
  public:
  void unsafe_arena_set_allocated_search_request(
      ::SearchRequest* search_request);
  ::SearchRequest* unsafe_arena_release_search_request();

  // .SearchResponse search_response = 5;
  bool has_search_response() const;
  private:
  bool _internal_has_search_response() const;
  public:
  void clear_search_response();
  const ::SearchResponse& search_response() const;
  ::SearchResponse* release_search_response();
  ::SearchResponse* mutable_search_response();
  void set_allocated_search_response(::SearchResponse* search_response);
  private:
  const ::SearchResponse& _internal_search_response() const;
  ::SearchResponse* _internal_mutable_search_response();
  public:
  void unsafe_arena_set_allocated_search_response(
      ::SearchResponse* search_response);
  ::SearchResponse* unsafe_arena_release_search_response();

  // .Model model = 6;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const ::Model& model() const;
  ::Model* release_model();
  ::Model* mutable_model();
  void set_allocated_model(::Model* model);
  private:
  const ::Model& _internal_model() const;
  ::Model* _internal_mutable_model();
  public:
  void unsafe_arena_set_allocated_model(
      ::Model* model);
  ::Model* unsafe_arena_release_model();

  // .Trajectory trajectory = 7;
  bool has_trajectory() const;
  private:
  bool _internal_has_trajectory() const;
  public:
  void clear_trajectory();
  const ::Trajectory& trajectory() const;
  ::Trajectory* release_trajectory();
  ::Trajectory* mutable_trajectory();
  void set_allocated_trajectory(::Trajectory* trajectory);
  private:
  const ::Trajectory& _internal_trajectory() const;
  ::Trajectory* _internal_mutable_trajectory();
  public:
  void unsafe_arena_set_allocated_trajectory(
      ::Trajectory* trajectory);
  ::Trajectory* unsafe_arena_release_trajectory();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:Packet)
 private:
  class _Internal;
  void set_has_heartbeat();
  void set_has_job_request();
  void set_has_preprocess_request();
  void set_has_search_request();
  void set_has_search_response();
  void set_has_model();
  void set_has_trajectory();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PayloadUnion {
    PayloadUnion() {}
    ::Heartbeat* heartbeat_;
    ::JobRequest* job_request_;
    ::PreprocessRequest* preprocess_request_;
    ::SearchRequest* search_request_;
    ::SearchResponse* search_response_;
    ::Model* model_;
    ::Trajectory* trajectory_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_czf_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MCTSRoot

// float value = 1;
inline void MCTSRoot::clear_value() {
  value_ = 0;
}
inline float MCTSRoot::_internal_value() const {
  return value_;
}
inline float MCTSRoot::value() const {
  // @@protoc_insertion_point(field_get:MCTSRoot.value)
  return _internal_value();
}
inline void MCTSRoot::_internal_set_value(float value) {
  
  value_ = value;
}
inline void MCTSRoot::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:MCTSRoot.value)
}

// repeated float policy = 2;
inline int MCTSRoot::_internal_policy_size() const {
  return policy_.size();
}
inline int MCTSRoot::policy_size() const {
  return _internal_policy_size();
}
inline void MCTSRoot::clear_policy() {
  policy_.Clear();
}
inline float MCTSRoot::_internal_policy(int index) const {
  return policy_.Get(index);
}
inline float MCTSRoot::policy(int index) const {
  // @@protoc_insertion_point(field_get:MCTSRoot.policy)
  return _internal_policy(index);
}
inline void MCTSRoot::set_policy(int index, float value) {
  policy_.Set(index, value);
  // @@protoc_insertion_point(field_set:MCTSRoot.policy)
}
inline void MCTSRoot::_internal_add_policy(float value) {
  policy_.Add(value);
}
inline void MCTSRoot::add_policy(float value) {
  _internal_add_policy(value);
  // @@protoc_insertion_point(field_add:MCTSRoot.policy)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
MCTSRoot::_internal_policy() const {
  return policy_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
MCTSRoot::policy() const {
  // @@protoc_insertion_point(field_list:MCTSRoot.policy)
  return _internal_policy();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
MCTSRoot::_internal_mutable_policy() {
  return &policy_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
MCTSRoot::mutable_policy() {
  // @@protoc_insertion_point(field_mutable_list:MCTSRoot.policy)
  return _internal_mutable_policy();
}

// -------------------------------------------------------------------

// GameOrigin

// bytes node = 1;
inline void GameOrigin::clear_node() {
  node_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GameOrigin::node() const {
  // @@protoc_insertion_point(field_get:GameOrigin.node)
  return _internal_node();
}
inline void GameOrigin::set_node(const std::string& value) {
  _internal_set_node(value);
  // @@protoc_insertion_point(field_set:GameOrigin.node)
}
inline std::string* GameOrigin::mutable_node() {
  // @@protoc_insertion_point(field_mutable:GameOrigin.node)
  return _internal_mutable_node();
}
inline const std::string& GameOrigin::_internal_node() const {
  return node_.Get();
}
inline void GameOrigin::_internal_set_node(const std::string& value) {
  
  node_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GameOrigin::set_node(std::string&& value) {
  
  node_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:GameOrigin.node)
}
inline void GameOrigin::set_node(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  node_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:GameOrigin.node)
}
inline void GameOrigin::set_node(const void* value,
    size_t size) {
  
  node_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:GameOrigin.node)
}
inline std::string* GameOrigin::_internal_mutable_node() {
  
  return node_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GameOrigin::release_node() {
  // @@protoc_insertion_point(field_release:GameOrigin.node)
  return node_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameOrigin::set_allocated_node(std::string* node) {
  if (node != nullptr) {
    
  } else {
    
  }
  node_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:GameOrigin.node)
}

// int32 index = 2;
inline void GameOrigin::clear_index() {
  index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameOrigin::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameOrigin::index() const {
  // @@protoc_insertion_point(field_get:GameOrigin.index)
  return _internal_index();
}
inline void GameOrigin::_internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  index_ = value;
}
inline void GameOrigin::set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:GameOrigin.index)
}

// -------------------------------------------------------------------

// Model

// repeated bytes blobs = 2;
inline int Model::_internal_blobs_size() const {
  return blobs_.size();
}
inline int Model::blobs_size() const {
  return _internal_blobs_size();
}
inline void Model::clear_blobs() {
  blobs_.Clear();
}
inline std::string* Model::add_blobs() {
  // @@protoc_insertion_point(field_add_mutable:Model.blobs)
  return _internal_add_blobs();
}
inline const std::string& Model::_internal_blobs(int index) const {
  return blobs_.Get(index);
}
inline const std::string& Model::blobs(int index) const {
  // @@protoc_insertion_point(field_get:Model.blobs)
  return _internal_blobs(index);
}
inline std::string* Model::mutable_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:Model.blobs)
  return blobs_.Mutable(index);
}
inline void Model::set_blobs(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:Model.blobs)
  blobs_.Mutable(index)->assign(value);
}
inline void Model::set_blobs(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:Model.blobs)
  blobs_.Mutable(index)->assign(std::move(value));
}
inline void Model::set_blobs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blobs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Model.blobs)
}
inline void Model::set_blobs(int index, const void* value, size_t size) {
  blobs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Model.blobs)
}
inline std::string* Model::_internal_add_blobs() {
  return blobs_.Add();
}
inline void Model::add_blobs(const std::string& value) {
  blobs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Model.blobs)
}
inline void Model::add_blobs(std::string&& value) {
  blobs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Model.blobs)
}
inline void Model::add_blobs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blobs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Model.blobs)
}
inline void Model::add_blobs(const void* value, size_t size) {
  blobs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Model.blobs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Model::blobs() const {
  // @@protoc_insertion_point(field_list:Model.blobs)
  return blobs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Model::mutable_blobs() {
  // @@protoc_insertion_point(field_mutable_list:Model.blobs)
  return &blobs_;
}

// -------------------------------------------------------------------

// Heartbeat

// -------------------------------------------------------------------

// JobRequest

// .JobType job_type = 1;
inline void JobRequest::clear_job_type() {
  job_type_ = 0;
}
inline ::JobType JobRequest::_internal_job_type() const {
  return static_cast< ::JobType >(job_type_);
}
inline ::JobType JobRequest::job_type() const {
  // @@protoc_insertion_point(field_get:JobRequest.job_type)
  return _internal_job_type();
}
inline void JobRequest::_internal_set_job_type(::JobType value) {
  
  job_type_ = value;
}
inline void JobRequest::set_job_type(::JobType value) {
  _internal_set_job_type(value);
  // @@protoc_insertion_point(field_set:JobRequest.job_type)
}

// int32 vacancy = 2;
inline void JobRequest::clear_vacancy() {
  vacancy_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JobRequest::_internal_vacancy() const {
  return vacancy_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JobRequest::vacancy() const {
  // @@protoc_insertion_point(field_get:JobRequest.vacancy)
  return _internal_vacancy();
}
inline void JobRequest::_internal_set_vacancy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vacancy_ = value;
}
inline void JobRequest::set_vacancy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vacancy(value);
  // @@protoc_insertion_point(field_set:JobRequest.vacancy)
}

// float efficiency = 3;
inline void JobRequest::clear_efficiency() {
  efficiency_ = 0;
}
inline float JobRequest::_internal_efficiency() const {
  return efficiency_;
}
inline float JobRequest::efficiency() const {
  // @@protoc_insertion_point(field_get:JobRequest.efficiency)
  return _internal_efficiency();
}
inline void JobRequest::_internal_set_efficiency(float value) {
  
  efficiency_ = value;
}
inline void JobRequest::set_efficiency(float value) {
  _internal_set_efficiency(value);
  // @@protoc_insertion_point(field_set:JobRequest.efficiency)
}

// -------------------------------------------------------------------

// PreprocessRequest

// .GameOrigin game_origin = 1;
inline bool PreprocessRequest::_internal_has_game_origin() const {
  return this != internal_default_instance() && game_origin_ != nullptr;
}
inline bool PreprocessRequest::has_game_origin() const {
  return _internal_has_game_origin();
}
inline void PreprocessRequest::clear_game_origin() {
  if (GetArena() == nullptr && game_origin_ != nullptr) {
    delete game_origin_;
  }
  game_origin_ = nullptr;
}
inline const ::GameOrigin& PreprocessRequest::_internal_game_origin() const {
  const ::GameOrigin* p = game_origin_;
  return p != nullptr ? *p : *reinterpret_cast<const ::GameOrigin*>(
      &::_GameOrigin_default_instance_);
}
inline const ::GameOrigin& PreprocessRequest::game_origin() const {
  // @@protoc_insertion_point(field_get:PreprocessRequest.game_origin)
  return _internal_game_origin();
}
inline void PreprocessRequest::unsafe_arena_set_allocated_game_origin(
    ::GameOrigin* game_origin) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_origin_);
  }
  game_origin_ = game_origin;
  if (game_origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PreprocessRequest.game_origin)
}
inline ::GameOrigin* PreprocessRequest::release_game_origin() {
  
  ::GameOrigin* temp = game_origin_;
  game_origin_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameOrigin* PreprocessRequest::unsafe_arena_release_game_origin() {
  // @@protoc_insertion_point(field_release:PreprocessRequest.game_origin)
  
  ::GameOrigin* temp = game_origin_;
  game_origin_ = nullptr;
  return temp;
}
inline ::GameOrigin* PreprocessRequest::_internal_mutable_game_origin() {
  
  if (game_origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameOrigin>(GetArena());
    game_origin_ = p;
  }
  return game_origin_;
}
inline ::GameOrigin* PreprocessRequest::mutable_game_origin() {
  // @@protoc_insertion_point(field_mutable:PreprocessRequest.game_origin)
  return _internal_mutable_game_origin();
}
inline void PreprocessRequest::set_allocated_game_origin(::GameOrigin* game_origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete game_origin_;
  }
  if (game_origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(game_origin);
    if (message_arena != submessage_arena) {
      game_origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_origin, submessage_arena);
    }
    
  } else {
    
  }
  game_origin_ = game_origin;
  // @@protoc_insertion_point(field_set_allocated:PreprocessRequest.game_origin)
}

// bytes observation = 2;
inline void PreprocessRequest::clear_observation() {
  observation_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PreprocessRequest::observation() const {
  // @@protoc_insertion_point(field_get:PreprocessRequest.observation)
  return _internal_observation();
}
inline void PreprocessRequest::set_observation(const std::string& value) {
  _internal_set_observation(value);
  // @@protoc_insertion_point(field_set:PreprocessRequest.observation)
}
inline std::string* PreprocessRequest::mutable_observation() {
  // @@protoc_insertion_point(field_mutable:PreprocessRequest.observation)
  return _internal_mutable_observation();
}
inline const std::string& PreprocessRequest::_internal_observation() const {
  return observation_.Get();
}
inline void PreprocessRequest::_internal_set_observation(const std::string& value) {
  
  observation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PreprocessRequest::set_observation(std::string&& value) {
  
  observation_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:PreprocessRequest.observation)
}
inline void PreprocessRequest::set_observation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  observation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:PreprocessRequest.observation)
}
inline void PreprocessRequest::set_observation(const void* value,
    size_t size) {
  
  observation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:PreprocessRequest.observation)
}
inline std::string* PreprocessRequest::_internal_mutable_observation() {
  
  return observation_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PreprocessRequest::release_observation() {
  // @@protoc_insertion_point(field_release:PreprocessRequest.observation)
  return observation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PreprocessRequest::set_allocated_observation(std::string* observation) {
  if (observation != nullptr) {
    
  } else {
    
  }
  observation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), observation,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:PreprocessRequest.observation)
}

// repeated int32 legal_actions = 3;
inline int PreprocessRequest::_internal_legal_actions_size() const {
  return legal_actions_.size();
}
inline int PreprocessRequest::legal_actions_size() const {
  return _internal_legal_actions_size();
}
inline void PreprocessRequest::clear_legal_actions() {
  legal_actions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PreprocessRequest::_internal_legal_actions(int index) const {
  return legal_actions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PreprocessRequest::legal_actions(int index) const {
  // @@protoc_insertion_point(field_get:PreprocessRequest.legal_actions)
  return _internal_legal_actions(index);
}
inline void PreprocessRequest::set_legal_actions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  legal_actions_.Set(index, value);
  // @@protoc_insertion_point(field_set:PreprocessRequest.legal_actions)
}
inline void PreprocessRequest::_internal_add_legal_actions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  legal_actions_.Add(value);
}
inline void PreprocessRequest::add_legal_actions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_legal_actions(value);
  // @@protoc_insertion_point(field_add:PreprocessRequest.legal_actions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
PreprocessRequest::_internal_legal_actions() const {
  return legal_actions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
PreprocessRequest::legal_actions() const {
  // @@protoc_insertion_point(field_list:PreprocessRequest.legal_actions)
  return _internal_legal_actions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
PreprocessRequest::_internal_mutable_legal_actions() {
  return &legal_actions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
PreprocessRequest::mutable_legal_actions() {
  // @@protoc_insertion_point(field_mutable_list:PreprocessRequest.legal_actions)
  return _internal_mutable_legal_actions();
}

// -------------------------------------------------------------------

// SearchRequest

// .GameOrigin game_origin = 1;
inline bool SearchRequest::_internal_has_game_origin() const {
  return this != internal_default_instance() && game_origin_ != nullptr;
}
inline bool SearchRequest::has_game_origin() const {
  return _internal_has_game_origin();
}
inline void SearchRequest::clear_game_origin() {
  if (GetArena() == nullptr && game_origin_ != nullptr) {
    delete game_origin_;
  }
  game_origin_ = nullptr;
}
inline const ::GameOrigin& SearchRequest::_internal_game_origin() const {
  const ::GameOrigin* p = game_origin_;
  return p != nullptr ? *p : *reinterpret_cast<const ::GameOrigin*>(
      &::_GameOrigin_default_instance_);
}
inline const ::GameOrigin& SearchRequest::game_origin() const {
  // @@protoc_insertion_point(field_get:SearchRequest.game_origin)
  return _internal_game_origin();
}
inline void SearchRequest::unsafe_arena_set_allocated_game_origin(
    ::GameOrigin* game_origin) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_origin_);
  }
  game_origin_ = game_origin;
  if (game_origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SearchRequest.game_origin)
}
inline ::GameOrigin* SearchRequest::release_game_origin() {
  
  ::GameOrigin* temp = game_origin_;
  game_origin_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameOrigin* SearchRequest::unsafe_arena_release_game_origin() {
  // @@protoc_insertion_point(field_release:SearchRequest.game_origin)
  
  ::GameOrigin* temp = game_origin_;
  game_origin_ = nullptr;
  return temp;
}
inline ::GameOrigin* SearchRequest::_internal_mutable_game_origin() {
  
  if (game_origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameOrigin>(GetArena());
    game_origin_ = p;
  }
  return game_origin_;
}
inline ::GameOrigin* SearchRequest::mutable_game_origin() {
  // @@protoc_insertion_point(field_mutable:SearchRequest.game_origin)
  return _internal_mutable_game_origin();
}
inline void SearchRequest::set_allocated_game_origin(::GameOrigin* game_origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete game_origin_;
  }
  if (game_origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(game_origin);
    if (message_arena != submessage_arena) {
      game_origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_origin, submessage_arena);
    }
    
  } else {
    
  }
  game_origin_ = game_origin;
  // @@protoc_insertion_point(field_set_allocated:SearchRequest.game_origin)
}

// bytes state = 2;
inline void SearchRequest::clear_state() {
  state_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SearchRequest::state() const {
  // @@protoc_insertion_point(field_get:SearchRequest.state)
  return _internal_state();
}
inline void SearchRequest::set_state(const std::string& value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:SearchRequest.state)
}
inline std::string* SearchRequest::mutable_state() {
  // @@protoc_insertion_point(field_mutable:SearchRequest.state)
  return _internal_mutable_state();
}
inline const std::string& SearchRequest::_internal_state() const {
  return state_.Get();
}
inline void SearchRequest::_internal_set_state(const std::string& value) {
  
  state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SearchRequest::set_state(std::string&& value) {
  
  state_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:SearchRequest.state)
}
inline void SearchRequest::set_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:SearchRequest.state)
}
inline void SearchRequest::set_state(const void* value,
    size_t size) {
  
  state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:SearchRequest.state)
}
inline std::string* SearchRequest::_internal_mutable_state() {
  
  return state_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SearchRequest::release_state() {
  // @@protoc_insertion_point(field_release:SearchRequest.state)
  return state_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SearchRequest::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:SearchRequest.state)
}

// repeated int32 legal_actions = 3;
inline int SearchRequest::_internal_legal_actions_size() const {
  return legal_actions_.size();
}
inline int SearchRequest::legal_actions_size() const {
  return _internal_legal_actions_size();
}
inline void SearchRequest::clear_legal_actions() {
  legal_actions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SearchRequest::_internal_legal_actions(int index) const {
  return legal_actions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SearchRequest::legal_actions(int index) const {
  // @@protoc_insertion_point(field_get:SearchRequest.legal_actions)
  return _internal_legal_actions(index);
}
inline void SearchRequest::set_legal_actions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  legal_actions_.Set(index, value);
  // @@protoc_insertion_point(field_set:SearchRequest.legal_actions)
}
inline void SearchRequest::_internal_add_legal_actions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  legal_actions_.Add(value);
}
inline void SearchRequest::add_legal_actions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_legal_actions(value);
  // @@protoc_insertion_point(field_add:SearchRequest.legal_actions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
SearchRequest::_internal_legal_actions() const {
  return legal_actions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
SearchRequest::legal_actions() const {
  // @@protoc_insertion_point(field_list:SearchRequest.legal_actions)
  return _internal_legal_actions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
SearchRequest::_internal_mutable_legal_actions() {
  return &legal_actions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
SearchRequest::mutable_legal_actions() {
  // @@protoc_insertion_point(field_mutable_list:SearchRequest.legal_actions)
  return _internal_mutable_legal_actions();
}

// -------------------------------------------------------------------

// SearchResponse

// .GameOrigin game_origin = 1;
inline bool SearchResponse::_internal_has_game_origin() const {
  return this != internal_default_instance() && game_origin_ != nullptr;
}
inline bool SearchResponse::has_game_origin() const {
  return _internal_has_game_origin();
}
inline void SearchResponse::clear_game_origin() {
  if (GetArena() == nullptr && game_origin_ != nullptr) {
    delete game_origin_;
  }
  game_origin_ = nullptr;
}
inline const ::GameOrigin& SearchResponse::_internal_game_origin() const {
  const ::GameOrigin* p = game_origin_;
  return p != nullptr ? *p : *reinterpret_cast<const ::GameOrigin*>(
      &::_GameOrigin_default_instance_);
}
inline const ::GameOrigin& SearchResponse::game_origin() const {
  // @@protoc_insertion_point(field_get:SearchResponse.game_origin)
  return _internal_game_origin();
}
inline void SearchResponse::unsafe_arena_set_allocated_game_origin(
    ::GameOrigin* game_origin) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_origin_);
  }
  game_origin_ = game_origin;
  if (game_origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SearchResponse.game_origin)
}
inline ::GameOrigin* SearchResponse::release_game_origin() {
  
  ::GameOrigin* temp = game_origin_;
  game_origin_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::GameOrigin* SearchResponse::unsafe_arena_release_game_origin() {
  // @@protoc_insertion_point(field_release:SearchResponse.game_origin)
  
  ::GameOrigin* temp = game_origin_;
  game_origin_ = nullptr;
  return temp;
}
inline ::GameOrigin* SearchResponse::_internal_mutable_game_origin() {
  
  if (game_origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameOrigin>(GetArena());
    game_origin_ = p;
  }
  return game_origin_;
}
inline ::GameOrigin* SearchResponse::mutable_game_origin() {
  // @@protoc_insertion_point(field_mutable:SearchResponse.game_origin)
  return _internal_mutable_game_origin();
}
inline void SearchResponse::set_allocated_game_origin(::GameOrigin* game_origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete game_origin_;
  }
  if (game_origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(game_origin);
    if (message_arena != submessage_arena) {
      game_origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_origin, submessage_arena);
    }
    
  } else {
    
  }
  game_origin_ = game_origin;
  // @@protoc_insertion_point(field_set_allocated:SearchResponse.game_origin)
}

// repeated .MCTSRoot mcts_roots = 2;
inline int SearchResponse::_internal_mcts_roots_size() const {
  return mcts_roots_.size();
}
inline int SearchResponse::mcts_roots_size() const {
  return _internal_mcts_roots_size();
}
inline void SearchResponse::clear_mcts_roots() {
  mcts_roots_.Clear();
}
inline ::MCTSRoot* SearchResponse::mutable_mcts_roots(int index) {
  // @@protoc_insertion_point(field_mutable:SearchResponse.mcts_roots)
  return mcts_roots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MCTSRoot >*
SearchResponse::mutable_mcts_roots() {
  // @@protoc_insertion_point(field_mutable_list:SearchResponse.mcts_roots)
  return &mcts_roots_;
}
inline const ::MCTSRoot& SearchResponse::_internal_mcts_roots(int index) const {
  return mcts_roots_.Get(index);
}
inline const ::MCTSRoot& SearchResponse::mcts_roots(int index) const {
  // @@protoc_insertion_point(field_get:SearchResponse.mcts_roots)
  return _internal_mcts_roots(index);
}
inline ::MCTSRoot* SearchResponse::_internal_add_mcts_roots() {
  return mcts_roots_.Add();
}
inline ::MCTSRoot* SearchResponse::add_mcts_roots() {
  // @@protoc_insertion_point(field_add:SearchResponse.mcts_roots)
  return _internal_add_mcts_roots();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MCTSRoot >&
SearchResponse::mcts_roots() const {
  // @@protoc_insertion_point(field_list:SearchResponse.mcts_roots)
  return mcts_roots_;
}

// -------------------------------------------------------------------

// Trajectory

// repeated int32 actions = 1;
inline int Trajectory::_internal_actions_size() const {
  return actions_.size();
}
inline int Trajectory::actions_size() const {
  return _internal_actions_size();
}
inline void Trajectory::clear_actions() {
  actions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Trajectory::_internal_actions(int index) const {
  return actions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Trajectory::actions(int index) const {
  // @@protoc_insertion_point(field_get:Trajectory.actions)
  return _internal_actions(index);
}
inline void Trajectory::set_actions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  actions_.Set(index, value);
  // @@protoc_insertion_point(field_set:Trajectory.actions)
}
inline void Trajectory::_internal_add_actions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  actions_.Add(value);
}
inline void Trajectory::add_actions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_actions(value);
  // @@protoc_insertion_point(field_add:Trajectory.actions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Trajectory::_internal_actions() const {
  return actions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Trajectory::actions() const {
  // @@protoc_insertion_point(field_list:Trajectory.actions)
  return _internal_actions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Trajectory::_internal_mutable_actions() {
  return &actions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Trajectory::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:Trajectory.actions)
  return _internal_mutable_actions();
}

// repeated float rewards = 2;
inline int Trajectory::_internal_rewards_size() const {
  return rewards_.size();
}
inline int Trajectory::rewards_size() const {
  return _internal_rewards_size();
}
inline void Trajectory::clear_rewards() {
  rewards_.Clear();
}
inline float Trajectory::_internal_rewards(int index) const {
  return rewards_.Get(index);
}
inline float Trajectory::rewards(int index) const {
  // @@protoc_insertion_point(field_get:Trajectory.rewards)
  return _internal_rewards(index);
}
inline void Trajectory::set_rewards(int index, float value) {
  rewards_.Set(index, value);
  // @@protoc_insertion_point(field_set:Trajectory.rewards)
}
inline void Trajectory::_internal_add_rewards(float value) {
  rewards_.Add(value);
}
inline void Trajectory::add_rewards(float value) {
  _internal_add_rewards(value);
  // @@protoc_insertion_point(field_add:Trajectory.rewards)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Trajectory::_internal_rewards() const {
  return rewards_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Trajectory::rewards() const {
  // @@protoc_insertion_point(field_list:Trajectory.rewards)
  return _internal_rewards();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Trajectory::_internal_mutable_rewards() {
  return &rewards_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Trajectory::mutable_rewards() {
  // @@protoc_insertion_point(field_mutable_list:Trajectory.rewards)
  return _internal_mutable_rewards();
}

// repeated .MCTSRoot mcts_roots = 3;
inline int Trajectory::_internal_mcts_roots_size() const {
  return mcts_roots_.size();
}
inline int Trajectory::mcts_roots_size() const {
  return _internal_mcts_roots_size();
}
inline void Trajectory::clear_mcts_roots() {
  mcts_roots_.Clear();
}
inline ::MCTSRoot* Trajectory::mutable_mcts_roots(int index) {
  // @@protoc_insertion_point(field_mutable:Trajectory.mcts_roots)
  return mcts_roots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MCTSRoot >*
Trajectory::mutable_mcts_roots() {
  // @@protoc_insertion_point(field_mutable_list:Trajectory.mcts_roots)
  return &mcts_roots_;
}
inline const ::MCTSRoot& Trajectory::_internal_mcts_roots(int index) const {
  return mcts_roots_.Get(index);
}
inline const ::MCTSRoot& Trajectory::mcts_roots(int index) const {
  // @@protoc_insertion_point(field_get:Trajectory.mcts_roots)
  return _internal_mcts_roots(index);
}
inline ::MCTSRoot* Trajectory::_internal_add_mcts_roots() {
  return mcts_roots_.Add();
}
inline ::MCTSRoot* Trajectory::add_mcts_roots() {
  // @@protoc_insertion_point(field_add:Trajectory.mcts_roots)
  return _internal_add_mcts_roots();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MCTSRoot >&
Trajectory::mcts_roots() const {
  // @@protoc_insertion_point(field_list:Trajectory.mcts_roots)
  return mcts_roots_;
}

// -------------------------------------------------------------------

// Packet

// .Heartbeat heartbeat = 1;
inline bool Packet::_internal_has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline bool Packet::has_heartbeat() const {
  return _internal_has_heartbeat();
}
inline void Packet::set_has_heartbeat() {
  _oneof_case_[0] = kHeartbeat;
}
inline void Packet::clear_heartbeat() {
  if (_internal_has_heartbeat()) {
    if (GetArena() == nullptr) {
      delete payload_.heartbeat_;
    }
    clear_has_payload();
  }
}
inline ::Heartbeat* Packet::release_heartbeat() {
  // @@protoc_insertion_point(field_release:Packet.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_payload();
      ::Heartbeat* temp = payload_.heartbeat_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Heartbeat& Packet::_internal_heartbeat() const {
  return _internal_has_heartbeat()
      ? *payload_.heartbeat_
      : *reinterpret_cast< ::Heartbeat*>(&::_Heartbeat_default_instance_);
}
inline const ::Heartbeat& Packet::heartbeat() const {
  // @@protoc_insertion_point(field_get:Packet.heartbeat)
  return _internal_heartbeat();
}
inline ::Heartbeat* Packet::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_payload();
    ::Heartbeat* temp = payload_.heartbeat_;
    payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_heartbeat(::Heartbeat* heartbeat) {
  clear_payload();
  if (heartbeat) {
    set_has_heartbeat();
    payload_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.heartbeat)
}
inline ::Heartbeat* Packet::_internal_mutable_heartbeat() {
  if (!_internal_has_heartbeat()) {
    clear_payload();
    set_has_heartbeat();
    payload_.heartbeat_ = CreateMaybeMessage< ::Heartbeat >(GetArena());
  }
  return payload_.heartbeat_;
}
inline ::Heartbeat* Packet::mutable_heartbeat() {
  // @@protoc_insertion_point(field_mutable:Packet.heartbeat)
  return _internal_mutable_heartbeat();
}

// .JobRequest job_request = 2;
inline bool Packet::_internal_has_job_request() const {
  return payload_case() == kJobRequest;
}
inline bool Packet::has_job_request() const {
  return _internal_has_job_request();
}
inline void Packet::set_has_job_request() {
  _oneof_case_[0] = kJobRequest;
}
inline void Packet::clear_job_request() {
  if (_internal_has_job_request()) {
    if (GetArena() == nullptr) {
      delete payload_.job_request_;
    }
    clear_has_payload();
  }
}
inline ::JobRequest* Packet::release_job_request() {
  // @@protoc_insertion_point(field_release:Packet.job_request)
  if (_internal_has_job_request()) {
    clear_has_payload();
      ::JobRequest* temp = payload_.job_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.job_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::JobRequest& Packet::_internal_job_request() const {
  return _internal_has_job_request()
      ? *payload_.job_request_
      : *reinterpret_cast< ::JobRequest*>(&::_JobRequest_default_instance_);
}
inline const ::JobRequest& Packet::job_request() const {
  // @@protoc_insertion_point(field_get:Packet.job_request)
  return _internal_job_request();
}
inline ::JobRequest* Packet::unsafe_arena_release_job_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.job_request)
  if (_internal_has_job_request()) {
    clear_has_payload();
    ::JobRequest* temp = payload_.job_request_;
    payload_.job_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_job_request(::JobRequest* job_request) {
  clear_payload();
  if (job_request) {
    set_has_job_request();
    payload_.job_request_ = job_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.job_request)
}
inline ::JobRequest* Packet::_internal_mutable_job_request() {
  if (!_internal_has_job_request()) {
    clear_payload();
    set_has_job_request();
    payload_.job_request_ = CreateMaybeMessage< ::JobRequest >(GetArena());
  }
  return payload_.job_request_;
}
inline ::JobRequest* Packet::mutable_job_request() {
  // @@protoc_insertion_point(field_mutable:Packet.job_request)
  return _internal_mutable_job_request();
}

// .PreprocessRequest preprocess_request = 3;
inline bool Packet::_internal_has_preprocess_request() const {
  return payload_case() == kPreprocessRequest;
}
inline bool Packet::has_preprocess_request() const {
  return _internal_has_preprocess_request();
}
inline void Packet::set_has_preprocess_request() {
  _oneof_case_[0] = kPreprocessRequest;
}
inline void Packet::clear_preprocess_request() {
  if (_internal_has_preprocess_request()) {
    if (GetArena() == nullptr) {
      delete payload_.preprocess_request_;
    }
    clear_has_payload();
  }
}
inline ::PreprocessRequest* Packet::release_preprocess_request() {
  // @@protoc_insertion_point(field_release:Packet.preprocess_request)
  if (_internal_has_preprocess_request()) {
    clear_has_payload();
      ::PreprocessRequest* temp = payload_.preprocess_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.preprocess_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PreprocessRequest& Packet::_internal_preprocess_request() const {
  return _internal_has_preprocess_request()
      ? *payload_.preprocess_request_
      : *reinterpret_cast< ::PreprocessRequest*>(&::_PreprocessRequest_default_instance_);
}
inline const ::PreprocessRequest& Packet::preprocess_request() const {
  // @@protoc_insertion_point(field_get:Packet.preprocess_request)
  return _internal_preprocess_request();
}
inline ::PreprocessRequest* Packet::unsafe_arena_release_preprocess_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.preprocess_request)
  if (_internal_has_preprocess_request()) {
    clear_has_payload();
    ::PreprocessRequest* temp = payload_.preprocess_request_;
    payload_.preprocess_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_preprocess_request(::PreprocessRequest* preprocess_request) {
  clear_payload();
  if (preprocess_request) {
    set_has_preprocess_request();
    payload_.preprocess_request_ = preprocess_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.preprocess_request)
}
inline ::PreprocessRequest* Packet::_internal_mutable_preprocess_request() {
  if (!_internal_has_preprocess_request()) {
    clear_payload();
    set_has_preprocess_request();
    payload_.preprocess_request_ = CreateMaybeMessage< ::PreprocessRequest >(GetArena());
  }
  return payload_.preprocess_request_;
}
inline ::PreprocessRequest* Packet::mutable_preprocess_request() {
  // @@protoc_insertion_point(field_mutable:Packet.preprocess_request)
  return _internal_mutable_preprocess_request();
}

// .SearchRequest search_request = 4;
inline bool Packet::_internal_has_search_request() const {
  return payload_case() == kSearchRequest;
}
inline bool Packet::has_search_request() const {
  return _internal_has_search_request();
}
inline void Packet::set_has_search_request() {
  _oneof_case_[0] = kSearchRequest;
}
inline void Packet::clear_search_request() {
  if (_internal_has_search_request()) {
    if (GetArena() == nullptr) {
      delete payload_.search_request_;
    }
    clear_has_payload();
  }
}
inline ::SearchRequest* Packet::release_search_request() {
  // @@protoc_insertion_point(field_release:Packet.search_request)
  if (_internal_has_search_request()) {
    clear_has_payload();
      ::SearchRequest* temp = payload_.search_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.search_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SearchRequest& Packet::_internal_search_request() const {
  return _internal_has_search_request()
      ? *payload_.search_request_
      : *reinterpret_cast< ::SearchRequest*>(&::_SearchRequest_default_instance_);
}
inline const ::SearchRequest& Packet::search_request() const {
  // @@protoc_insertion_point(field_get:Packet.search_request)
  return _internal_search_request();
}
inline ::SearchRequest* Packet::unsafe_arena_release_search_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.search_request)
  if (_internal_has_search_request()) {
    clear_has_payload();
    ::SearchRequest* temp = payload_.search_request_;
    payload_.search_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_search_request(::SearchRequest* search_request) {
  clear_payload();
  if (search_request) {
    set_has_search_request();
    payload_.search_request_ = search_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.search_request)
}
inline ::SearchRequest* Packet::_internal_mutable_search_request() {
  if (!_internal_has_search_request()) {
    clear_payload();
    set_has_search_request();
    payload_.search_request_ = CreateMaybeMessage< ::SearchRequest >(GetArena());
  }
  return payload_.search_request_;
}
inline ::SearchRequest* Packet::mutable_search_request() {
  // @@protoc_insertion_point(field_mutable:Packet.search_request)
  return _internal_mutable_search_request();
}

// .SearchResponse search_response = 5;
inline bool Packet::_internal_has_search_response() const {
  return payload_case() == kSearchResponse;
}
inline bool Packet::has_search_response() const {
  return _internal_has_search_response();
}
inline void Packet::set_has_search_response() {
  _oneof_case_[0] = kSearchResponse;
}
inline void Packet::clear_search_response() {
  if (_internal_has_search_response()) {
    if (GetArena() == nullptr) {
      delete payload_.search_response_;
    }
    clear_has_payload();
  }
}
inline ::SearchResponse* Packet::release_search_response() {
  // @@protoc_insertion_point(field_release:Packet.search_response)
  if (_internal_has_search_response()) {
    clear_has_payload();
      ::SearchResponse* temp = payload_.search_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.search_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SearchResponse& Packet::_internal_search_response() const {
  return _internal_has_search_response()
      ? *payload_.search_response_
      : *reinterpret_cast< ::SearchResponse*>(&::_SearchResponse_default_instance_);
}
inline const ::SearchResponse& Packet::search_response() const {
  // @@protoc_insertion_point(field_get:Packet.search_response)
  return _internal_search_response();
}
inline ::SearchResponse* Packet::unsafe_arena_release_search_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.search_response)
  if (_internal_has_search_response()) {
    clear_has_payload();
    ::SearchResponse* temp = payload_.search_response_;
    payload_.search_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_search_response(::SearchResponse* search_response) {
  clear_payload();
  if (search_response) {
    set_has_search_response();
    payload_.search_response_ = search_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.search_response)
}
inline ::SearchResponse* Packet::_internal_mutable_search_response() {
  if (!_internal_has_search_response()) {
    clear_payload();
    set_has_search_response();
    payload_.search_response_ = CreateMaybeMessage< ::SearchResponse >(GetArena());
  }
  return payload_.search_response_;
}
inline ::SearchResponse* Packet::mutable_search_response() {
  // @@protoc_insertion_point(field_mutable:Packet.search_response)
  return _internal_mutable_search_response();
}

// .Model model = 6;
inline bool Packet::_internal_has_model() const {
  return payload_case() == kModel;
}
inline bool Packet::has_model() const {
  return _internal_has_model();
}
inline void Packet::set_has_model() {
  _oneof_case_[0] = kModel;
}
inline void Packet::clear_model() {
  if (_internal_has_model()) {
    if (GetArena() == nullptr) {
      delete payload_.model_;
    }
    clear_has_payload();
  }
}
inline ::Model* Packet::release_model() {
  // @@protoc_insertion_point(field_release:Packet.model)
  if (_internal_has_model()) {
    clear_has_payload();
      ::Model* temp = payload_.model_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Model& Packet::_internal_model() const {
  return _internal_has_model()
      ? *payload_.model_
      : *reinterpret_cast< ::Model*>(&::_Model_default_instance_);
}
inline const ::Model& Packet::model() const {
  // @@protoc_insertion_point(field_get:Packet.model)
  return _internal_model();
}
inline ::Model* Packet::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.model)
  if (_internal_has_model()) {
    clear_has_payload();
    ::Model* temp = payload_.model_;
    payload_.model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_model(::Model* model) {
  clear_payload();
  if (model) {
    set_has_model();
    payload_.model_ = model;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.model)
}
inline ::Model* Packet::_internal_mutable_model() {
  if (!_internal_has_model()) {
    clear_payload();
    set_has_model();
    payload_.model_ = CreateMaybeMessage< ::Model >(GetArena());
  }
  return payload_.model_;
}
inline ::Model* Packet::mutable_model() {
  // @@protoc_insertion_point(field_mutable:Packet.model)
  return _internal_mutable_model();
}

// .Trajectory trajectory = 7;
inline bool Packet::_internal_has_trajectory() const {
  return payload_case() == kTrajectory;
}
inline bool Packet::has_trajectory() const {
  return _internal_has_trajectory();
}
inline void Packet::set_has_trajectory() {
  _oneof_case_[0] = kTrajectory;
}
inline void Packet::clear_trajectory() {
  if (_internal_has_trajectory()) {
    if (GetArena() == nullptr) {
      delete payload_.trajectory_;
    }
    clear_has_payload();
  }
}
inline ::Trajectory* Packet::release_trajectory() {
  // @@protoc_insertion_point(field_release:Packet.trajectory)
  if (_internal_has_trajectory()) {
    clear_has_payload();
      ::Trajectory* temp = payload_.trajectory_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.trajectory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Trajectory& Packet::_internal_trajectory() const {
  return _internal_has_trajectory()
      ? *payload_.trajectory_
      : *reinterpret_cast< ::Trajectory*>(&::_Trajectory_default_instance_);
}
inline const ::Trajectory& Packet::trajectory() const {
  // @@protoc_insertion_point(field_get:Packet.trajectory)
  return _internal_trajectory();
}
inline ::Trajectory* Packet::unsafe_arena_release_trajectory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.trajectory)
  if (_internal_has_trajectory()) {
    clear_has_payload();
    ::Trajectory* temp = payload_.trajectory_;
    payload_.trajectory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_trajectory(::Trajectory* trajectory) {
  clear_payload();
  if (trajectory) {
    set_has_trajectory();
    payload_.trajectory_ = trajectory;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.trajectory)
}
inline ::Trajectory* Packet::_internal_mutable_trajectory() {
  if (!_internal_has_trajectory()) {
    clear_payload();
    set_has_trajectory();
    payload_.trajectory_ = CreateMaybeMessage< ::Trajectory >(GetArena());
  }
  return payload_.trajectory_;
}
inline ::Trajectory* Packet::mutable_trajectory() {
  // @@protoc_insertion_point(field_mutable:Packet.trajectory)
  return _internal_mutable_trajectory();
}

inline bool Packet::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Packet::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Packet::PayloadCase Packet::payload_case() const {
  return Packet::PayloadCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::JobType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::JobType>() {
  return ::JobType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_czf_2eproto
